[{"title":"游泳攻略","date":"2017-06-10T07:23:51.000Z","path":"2017/06/10/游泳攻略/","text":"游泳攻略 引言 游泳是一种全身性运动，素有“运动之王”的美称，可以避免常规运动可能造成的关节损伤，而且老少皆宜。益处多多，待我一一道来 1、保护身体多处关节的健康 游泳锻炼是克服水的阻力而不是克服重力， 肌肉和关节不易受伤在游泳时，在水的浮力和阻力的相互作用下，身体能够得到按摩，起到很好的保健作用。 2、能够能起到减肥的作用 游泳一项全身的运动，因此，随着全身的运动，肌肉会松弛舒展，人体的脂肪消耗得更快（水温低，热量流失快），使得身体更加匀称、协调。 3、改善心血管系统的功能 游泳时要克服水的阻力需要动用较多的能量，使心率加快，心输出量增大。坚持长期进行游泳锻炼，心脏体积呈运动性增大，心肌收缩有力，安静心率减慢，每搏输出量增加，血管壁增厚，弹性加大，心血管系统的效率得到提高。 4、改善体温调节机能 由于水的温度一般低于气温，水的导热能力又比空气强数十倍，因此人在水中失散的热量远远快于在空气中。经常游泳能改善体温调节能力，从而更能够承受外界温度的变化。 5、调节内分泌 游泳还能够起到改善内分泌失调的作用,让人减少焦虑、心态更为平和,皮肤也更加光滑美丽,这些都让女性在性生活中更有魅力，令心情放松。 6、塑造肌肉线条、增强肌肉力度、提高身体柔韧与协调 游泳动作属于伸展运动，而且需要多肌肉群的协调，因此对于塑形和协调有很大的帮助。 7、改善脊椎问题 游泳是公认对脊椎有好处的运动，个人觉得更多的是来自蛙泳的好处，蛙泳的时候，头一低一抬，增强后颈肌肉力量，改善驼背和颈椎病。胸椎有肋骨防护，一般很难出现问题，因为两侧有心脏肺等各种主要器官，一旦出现问题，即便是小错位都够受的，划船和蛙泳的划手动作都可以有效的加强胸椎的防护能力。 8、误区 即便游泳有各种好处，但并不代表你可以随意的游，错误的动作可能带来严重的后果，详见【常见问题与误区篇】 一、必备装备篇（一）泳帽作用 希望在泳池游泳都能自觉戴泳帽，一方面保护自己的头发，也可以减少游泳阻力另一方面也防止脱发影响泳者发挥和泳池的过滤系统。 分类 泳帽一般分为布帽、PU帽、胶帽。 布帽 防水性能差，和头的密合性差，佩戴较为舒适，不推荐；如果是一次性游泳的话布帽是首选，物美价廉，但是一般只有小区泳池可戴布帽，较为标准的泳池大都要求戴PU或胶帽。 PU帽 复合材料的泳帽，和头的密合性和防水性都是介于布帽和胶帽之间，舒适度一般。 胶帽 不透水，和头的密合性佳，佩戴有小小紧勒感，最大化的减小阻力，强烈推荐。 佩戴 泳帽都有折痕，棱边对准眉心，从前往后戴；妹纸的话推荐第二种方法，把泳帽撑开，从后往前，尽量把头发都套住，同样是棱边要对准眉心，如果折痕在两边，无法形容，反正很丑。准确的来说泳帽要套住耳朵防止进水，但是太勒了，不推荐。 （泳帽的正确戴法）选择 最好选择跟泳装同色或近色，当然个性的花花绿绿也是可以的，赚足回头率。### （二）泳镜作用 避免眼睛接触池水后发炎或被感染，不过最主要的原因当然是看妹纸啦。分类 大致特征有大框、小框、镀膜、非镀膜。选择- 慎选全透明泳镜，看起来眼珠子都要突出来了，你喜欢的话我也拦不住。- 莫选大框泳镜，特别是潜水镜，相对来说防水性没有小框的好，而且不好看，略浮夸。- 一定要买防雾的，特别是冬天。- 200度近视以下可以不买近视泳镜，200度以上的不用近视泳镜就是你的损失了，想想有个美女经过而你又看不清，可悲可叹。散光者，散光度数除以2，加上近视的度数，就是理想的泳镜度数。- 推荐小框泳镜，防水又专业。- 室内选浅色透明（室内较暗，用电镀看不太清）- 室外选电镀（光线较强，可防紫外线，而且别人看不到你的眼睛，显得比较酷炫高冷，hehe~）。 保养 切忌用热水洗 镜内莫洗 戴久了要摘一下，防止局部缺氧对眼睛不好 不管买的时候宣传的防雾功能多好，基本用几次就不防雾了，网上卖的防雾剂效果跟直接用洗洁精或者肥皂差不多。或者你也可以像专业选手一样，舔一舔。我试过，口感一般2333 （三）泳装 泳裤分类 泳裤的区分主要是长度，另外是材料（影响泳裤的寿命，然而不管什么材料，不要坐在泳池边，也不要用热水洗，泳裤表示心很累）。 长度 大致分为三角、平角、五分、到脚踝、连体、全覆盖。 以前面料发展还不发达的时候，以减小阻力为目的尽量减少覆盖面积，所以大多选择低腰三角泳裤，目前的话这类泳裤在西方国家是带有“特定标签”的人使用的，除非你技术棒棒哒，否则还是不要引起误会了。 推荐平角泳裤或五分裤，中规中矩，来看看泳届大佬的装备。（低边平角泳裤）（普通平角泳裤）（五分泳裤） 超过五分长的泳裤就不推荐了，由于泳装发展太快太牛逼，各种高科技泳装层出不穷，现在国际比赛已经规定比赛的时候泳裤只能到膝盖。 泳衣分类 这里主要针对妹纸来讲，泳衣大致可分为连体和衣裤分离 背交叉连体（推荐） 较为时尚流行的背交叉连体（推荐） 三角连体（一般般） 带小花边连体（泡水还可以，游的话兜水，而且大都是肩带型，不推荐。还不如穿比基尼2333） 竞速泳衣（土豪与专业人士可选，相当的紧，上图的背交叉连体就是） 比基尼（男士福音，身材好的不管是认真游还是泡水都很好看，我喜欢2333） 选择 材料方面没什么研究，一般买贴身速干的就可以了，泡水群众可以买宽松的，专业的可以选择高压缩型的，看看傅爷这表情就知道高压缩型的有多紧了 （四）物品寄放一般分为以下几种 押金寄物（有些全退，像长隆那些记得是押50退20酱紫） 投币寄物（一般是一个或两个硬币，坑爹的设计，感觉带钢镚不爽） 自备锁（这种是最好也是最常见的） 锁的选择 带钥匙的（不推荐，为了防止钥匙掉落，普通手绳易坏，推荐钥匙手环，几毛钱） 密码锁（推荐，没有钥匙掉落的风险，也不会因为手环影响发挥，一般也就几块钱） 二、辅助装备篇（一）耳塞很少有人戴，而且容易掉水里，比赛都是泳帽直接盖住耳朵达到防水效果 （二）鼻夹不是花样游泳一般都不戴，虽说有防鼻子进水的效果，但是容易产生依赖，影响换气的学习。另外，汉子还是不要戴了，妹纸随便，感觉挺好看~ （三）背漂（泳圈同理）一般儿童用，不推荐。一样容易产生依赖，影响动作。推荐8字浮板，下面会讲到。 （四）打水浮板 新手必备神器，一般是下图这种，一般用来练打腿 墙裂推荐，理由是它可以像上面的浮板一样用来练打腿，也可以，夹在腿间让下半身浮起来，用来练手划水动作（不推荐背漂的原因）。 （五）跟屁虫/漂流包/潜浮包 不管水性如何，野泳的时候一定要带，尊重自己与他人的生命。（不会游的最好不要野泳，这种也只是对会游的有基本的保障） 常见的跟屁虫长这样，橙色有警醒作用，小的不能储物，大的可以放点东西，不过不能太多，基本满足。（小跟屁虫）（大跟屁虫）不过现在大都流行这种漂流包，比较好看，可以承受更大的重量，切记，表买单肩的（六）划水掌现在划水掌做得都很好看了，各式各样，自行选择 作用 适用中高阶爬泳者，可以有效改正手臂划水的动作，增大划水面积，可以划得更快，最主要的还是为了手臂力量得到训练。不要过份依赖，戴久了会导致腿打水时转跨配合力度变小，不戴的时候协调性就变差了。 选择 买跟手掌差不多大小的就行，不要买太大的，费力不说，还容易受伤。 （七）脚蹼作用 练蝶泳必备，可以让你更好的感受到身体的波动，纠正姿势，保持上下S型前进的动力。 选择 买游泳型的就行，如图 不要买成下面这种潜水型的，不过这种用来练波动好像更好。 （八）其它 呼吸管（分游泳和潜水用，游泳的可以忽略呼吸专心练动作，不推荐。我主张先适应水先学会换气再学动作） 阻力裤（原理是兜水，加重阻碍前进，用以力量训练） 拉力筋（一头绑腰上，手拿着另一头，用以力量训练） 三、沐浴装备篇理由 特别是泳池，大都加了混凝剂和一些含氯的消毒品，对头发跟皮肤有一定的伤害，所以游泳必备篇的装备防水性很重要。同时，沐浴用品也很重要，我一般洗完回去再洗都还有一点点漂白水的味道，想象以下如果游泳后就简单冲一下，等回去再洗，期间氯在你身上悠哉的进行化学反应，啧啧。 清单 洗发水 护发素（可以游之前涂一点在泳帽内侧，厉害了2333） 沐浴露 毛巾/浴巾 拖鞋 吹风筒 选择 现在有去氯的沐浴用品，用后也没啥区别，心理作用。觉得普通的平时用的就行（不懂，保留意见） 毛巾/浴巾必须有有木有，忘带的时候用衣服擦干，唉~都是泪。 拖鞋不一定要，带的话会方便很多，洗完后脚湿的总不能直接穿鞋吧。 有些游泳馆有吹风筒（少见），有些没有，妹纸有需要可以自带吹风筒，不过没啥必要，因为大多泳馆并没有插头。/无辜脸 分装瓶 大大小小的瓶子带起来不方便咋办，放包里可能还会漏出来（说多都是泪），推荐这种分装瓶，最好买压嘴的，白色透明的话可以根据颜色分清是什么，不用像我一样贴标签，而且有个卡扣，不怕不小心压到，用起来比较方便，几毛钱一个，不过加上邮费就贵了。 四、技术篇（视频学习较好）小生浅见，欢迎大佬斧正。 水性 解释以下水性是什么，不是你游多快，会多少种游法，体力多好，耐力多好。而是指对水的适应程度，如果你泳镜突然掉了或者突然抽筋了，你就变得很紧张，那只能说你水性还不到家。这也是很多新手的问题，对水的恐惧感。 水感与呼吸 不建议直接上来就是干，新手要先体验一下水感，可以在浅水区行走，感受水的波动，然后尝试向前、向侧、向后的走、跑、跳，。 适应了之后练习呼吸，不管什么运动，呼吸都是重中之重，要领是出水口吸气，不要用鼻子，会呛水。入水口鼻吐气，重点在鼻吐气，一般很累很喘的时候才用到口吐气，入水的时候不要憋气，入水临界点的时候就开始吐气，不要吐尽，吐尽就会有憋的感觉，留一口气在出水的临界点吐掉，然后快速在吸一口，赛过活神仙。 虽然我是主张先打好基础在练动作的，但是这种练习显得很枯燥，初学者会觉得很无聊，在现在快节奏的生活和快餐文化的氛围下，初学者学水感和呼吸的时候不会有丝毫成就感，容易厌倦。但是游前5分钟的练习和适应还是很有必要的（不论新手老手） 狗爬 顾名思义就是像狗一样手脚扒水，大多数江湖海边玩大的基本都是狗爬，俺一开始也是，这是一种本能反应，3个月大的婴儿就开始有的踢踏反射动作，淹也淹不死，游也游不快，毕竟费力和low了点，学点比赛泳姿还是有必要的。 仰泳 可用反蛙泳、反爬泳、反蝶泳法游，没专门练过，不发表意见，放个妹纸镇场。 蛙泳 蛙泳分手和脚的练习，脚有三个动作：收、翻、蹬，手的动作也有三个：划水，收手，伸手。 收 双腿伸直，腿往胸口收（没那么夸张，形象一点而已），最多和身体呈90度 翻 重点动作，翻不过来是柔韧度不够，需要配合压筋练习。膝盖外翻，脚尖向外（这是重点），可以在陆上让人抓着脚练习，让肌肉记忆动作。 蹬夹 这里其实是两个动作，一个是向两侧蹬，一个是双腿并拢。必须连贯起来（画弧形，这是腿法精髓，前进动力在此） 划水 划水分为外划和内划，外划的时候想象一下手往两边拨开一层水 内划在外划的基础上，手弯曲角度大概120度 收手 收手即为抱水，这是手部动作的精髓，在泳池里经常可以看到很多人划到腰间再收回来，这是错误的，我称之为养生蛙，不能笑（哈哈哈~），抱水应该在胸口进行抱水，看一下大佬的抱水动作，想象一下手里托着个宝贝 伸手 这个没什么讲的，就是从抱水后的一个前冲动作，要记住伸手之后才蹬腿 配合 外划腿不动，内划慢收腿，收手后收腿，伸手快蹬夹，手脚伸直漂一会 爬泳 爬泳就是常说的自由泳，详见【常见问题篇】，也是分为手和腿的练习，大多数培训都是从蛙泳开始教起，个人认为蛙泳动作复杂，不适合初学，爬泳动作较为简单，容易产生前进力，初学者容易找到成就感，不会中途放弃，废话不多说，一般从打腿开始练习 打腿第一阶段 因为初学者腿部柔韧性不够，所以要拉筋拉筋拉筋，重要的事说三遍，一开始还比较僵硬，要点是膝盖和脚绷直（不要蹦死，易抽筋，放松，有点弯曲也可以接受），然后就上下小幅度的打水即可 打腿第二阶段 腿像鞭子一样打水，大腿是手臂，小腿是棍子，棍子本身是不发力的，只有手臂发力才能发挥作用，爬泳打腿也是，要大腿带动小腿打水，如果感觉小腿弯曲后用力打水就是错误的（这就是第一阶段要膝盖绷直练的原因），另外，打水的时候内八，力学问题，不用刻意，基本都是很自然就内八的。 打腿第三阶段 这是精髓，腿可以自然打水后，注意力放在髋部，上文说的大腿带动小腿，其实发力点是通过髋部的转动带动的，从侧面看比较好理解，这个时候腿相对于水平面来说不是上下打水，而是要做一个转动打水的动作。 打腿第四阶段 这里讲打腿频率，初学的时候都是死命的打，谁管你二次腿四次腿还是六次腿，最常见的就是六次腿（指的是左右手划动一次打腿的次数），很多人感觉爬泳很累，因为大多数人都是用六次甚至毫无规律的频率来打水的，六次腿只会在冲刺阶段用到，如果用这种频率在平时嬉戏中，不累才怪。四次腿比较少见，这里主要讲二次腿，长游必备。说白了真正掌握爬泳呼吸规律的时候可以很自然控制打腿频率。动作跟我们走路一样，一次手一次腿，不要顺拐喽（只要记住左手伸右腿打，右手伸左腿打就可以），看到【打腿第三阶段】那里的图没有，那个动作的下一步就是右手入水（伸），这时图中的左腿是在上方的，当右手伸的时候左腿就向下打腿，自行领悟。 手臂第一阶段 手伸直做预备态，开始划水，手臂之间呈120度角度向后划水，练习的时候拇指擦着打腿经过把划水动作进行到底 手臂第二阶段 空中移臂，这是最精髓也是最容易出错的地方，切记，爬泳划水的任何时候，肘的位置都是高于手的，把意念都放在肘上，想象肘带着你的手在运动，有助于练习。最好回去看镜子练习，做不出动作的再说三遍压筋压筋压筋。下图分别为错误示范，柔韧度不够但是正确的移臂以及正确的移臂 这种就是手高于肘，移臂很累又不好看这个动作是对的，只是柔韧性不够，手抬得太高了 正确的爬泳移臂 手臂第三阶段 入水，角度如图，这里要讲一下两手的配合，在长游的时候，一只手完全入水后另一手才开始划水，只有比赛的时候为了速度，才需要在移臂准备入水的时候另一手开始划水。 换气 一般是划3次手换一次气，我体力不足，反正我基本10来分钟后就都是2次手换一次气（这里就要注意不要只一边换气了，详见【常见问题篇】），千万不要一次换一下，那是不可能的，看起来就是左边甩一下，右边甩一下，看着都费劲。 换气的时机在于哪只手划水，就哪边换气，从开始划水到移臂结束为吸气阶段，入水开始吐气，看到没有，吸气的阶段很足，这就是爬泳适合长游的原因，速度快又不费劲。练习的时候，手开始划的时候下巴贴着锁骨，眼睛往斜后方看。正确的换气是只露出半个泳镜（如手臂第三阶段图），不用担心呛水，人前进的时候嘴边形成了真空地带，不用怕，做不到的整个脸都向上，也可以，像下面这种。 蝶泳 终于讲到我最喜欢的了，蝶泳在实际游泳中并没有太大的作用。但作为一种运动项目，最主要的意义还是在于锻炼，爆发力强，对身体协调能力要求高。所以短时间内力量需求和热量消耗更大。对上肢肌肉锻炼效果明显。还有一个最最重要的理由，蝶泳可以装逼，无限美感，清场必备。咳咳，下面开始入门 蝶泳腿第一阶段 也叫海豚腿，任何泳姿比赛起跳的时候都会采用蝶泳腿，为什么，快。 陆上练习：看过钢管舞的身体波动没有（搜舞蹈wave），对着镜子练，我觉得我一个汉子练这个也还看得下去2333，建议练全身，港真，实际只要练腿也可以啦。如图，先顶跨，然后膝盖弯曲，屁股后翘，不要直接站直，膝盖往回收，画个弧度回归 水里练习：最好戴个脚蹼，可以感受身体的波动，练习的时候压胸产生前进动力，后半身随波逐流，屁股稍微抬一下露出水面，这个阶段会有点久，一开始会一直往水下潜，慢慢习惯就可以了。 蝶泳腿第二阶段 当可以很自然的作出海豚腿的动作的时候，你会发现，游不快，这个时候意念就不要放在压胸上了，用力甩动你的腰，你会飞快的前进，这里小小练习一下就能进阶了。 手臂练习 蝶泳手臂跟爬泳完全一样，可以在陆地先单手练，然后双手练。 单手蝶 单手蝶的练习是很有必要的，蝶泳的时候累了可以用单手蝶过度一下。单手蝶不需要像双手蝶那样配合，像爬泳一样，一只手划水，然后用海豚泳的腿法打水1-3下都可以。 蛙腿蝶手/蝶腿蛙手 主要为了游的时候着重练习蝶手或蝶腿，体会手脚配合的节奏。 配合（难点） 重中之重的部分，文字比较难表达，建议看慢蝶的视频，容易看出端倪。这里分别讲手跟腿的时机。全身伸直做预备状态，开始抱水划水，腰微塌下去，脚自然就上来了，如图 接下来是第一次打腿也是最重要的一次，重点发力，带动身体出水，吸气，要感觉身体是贴着水面的前进的，不要为了吸气成直力型。如图，看出水角度接下来空中移臂的过程很快结束，手入水，两手入水姿势同爬泳，注意间隔差不多与肩同宽，不用特别在意，手入水的瞬间还没入水，迅速做第二次打腿，这次力道可以小一点，这个时候手刚好入水，用抬腰（有一种把屁股网上甩的感觉），为下一次打腿做准备。 换气 蝶泳的换气跟蛙泳有异曲同工之妙，划水的时候出水吸气，手出水的时候低头吐气。 暴力蝶与慢蝶 两者的区别是暴力蝶在于速度，而慢蝶适合长游。上文讲的都是暴蝶，而慢蝶慢在滑行，就是腰发力的时候，还有一个显著的地方，就如上文第二次打腿的时候，本来应该手还没入水就开始迅速打腿，而慢蝶恰恰是等入水后再悠哉悠哉的打一下腿，再滑行一下，除了抱水跟打腿都要迅速，其它整体节奏放慢。 注意 蝶泳需要很高的协调力，即便慢蝶也需要很好的体力和耐力，否则蝶个100米就累了，这里讲累的时候出现的问题，因为身体腰腹力量是短板，其它肌肉还有余力的时候，腰已经没力，这种时候很容易不自觉的切换成小腿打水，这是常见现象，我也是这样玩得不亦乐乎的。不过建议动作变形就不要继续了。 转身与跳水 只做出摸墙转身和爬泳的背泳翻滚转身动作，不标准，没专门学过就不发表意见了。 五、常见问题篇 游泳会使肌肉线条拉长，在于塑形，并不能练出大块肌肉，器械健身在于紧实肌肉，如果两者配合简直无敌。 学游泳不止水里要练，陆地练习也很重要，可以看着镜子，模拟水中动作，看看自己是否动作变形，多练习，让肌肉记忆动作。 有些人动作永远做不好，是身体柔韧性不够，需要配合陆地的压筋联系。 其它泳姿动作错误会影响游泳速度，但是要特别注意爬泳和单手蝶，在泳池可以看到很多人游着游着就游偏了，而且只能单边换气，这是因为双手双脚力量不对等导致的，出现这种情况一定要着重练某一边的力量。如果爬泳做不到三划一换气，可以半场一边换气，下半场换另一半换气。单手蝶同理。如果不注意的话，可能造成严重后果，两边肌肉不平衡反而对脊椎不好。 一个常识误区，自由泳的意思是你可以用任何泳姿游，只是在比赛的时候由于爬泳速度最快，所以自由泳都采取爬泳的姿势。so，记住就好，不要闹笑话。 腰不好不要蝶泳，好好静养吧。","tags":[{"name":"Swimming","slug":"Swimming","permalink":"http://yoursite.com/tags/Swimming/"}]},{"title":"使用kong管理api","date":"2017-06-05T06:42:16.000Z","path":"2017/06/05/使用kong管理api/","text":"摘要：Kong，Mashape开源的API层。是基于Nginx_Lua模块写的。是一个基于openresty的api代理层，数据采用了 Apache Cassandra/PostgreSQL存储，并且提供了一些优秀的插件，比如验证，日志，调用频次限制等。详细资料见官网：https://getkong.org环境：ubuntu 16.041、下载kong：https://getkong.org/install/ 在此页面选择你的系统，之后再下载相应的系统版本，因为我是 unbuntu 16.04，则下载https://github.com/Mashape/kong/releases/download/0.10.3/kong-0.10.3.xenial_all.deb 2、安装kong，根据官网提示，执行下面三条命令123$ sudo apt-get update$ sudo apt-get install openssl libpcre3 procps perl$ sudo dpkg -i kong-0.10.3.*.deb 3、kong的使用肯定需要存储一些自己的数据，目前支持PostgreSQL和Cassandra两种数据库，这里以postgresql为例进行安装 3.1 添加postgresql源：12$ sudo touch /etc/apt/sources.list.d/pgdb.list$ sudo vim /etc/apt/sources.list.d/pgdb.list 3.2 将下文添加到pgdb.list中1deb https://apt.postgresql.org/pub/repos/apt/ trusty-pgdg main 3.3 执行如下命令添加postgresql安装包的秘钥：1$ sudo wget --quiet -O - https://postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - 3.4 安装12sudo apt-get updatesudo apt-get install postgresql-9.4 3.5 验证是否成功1$ dpkg -l |grep postgresql 3.6 看到如下信息则为成功123456ii pgdg-keyring 2017.1 all keyring for apt.postgresql.orgii postgresql-9.4 9.4.12-1.pgdg14.04+1 amd64 object-relational SQL database, version 9.4 serverii postgresql-client-9.4 9.4.12-1.pgdg14.04+1 amd64 front-end programs for PostgreSQL 9.4ii postgresql-client-common 182.pgdg14.04+1 all manager for multiple PostgreSQL client versionsii postgresql-common 182.pgdg14.04+1 all PostgreSQL database-cluster managerii postgresql-contrib-9.4 9.4.12-1.pgdg14.04+1 amd64 additional facilities for PostgreSQL 3.7 postgres是超级管理员，类似mysql的root和sqlserver的sa，一开始是没有密码的，用超级管理员登录1$ sudo -i -u postgres 3.8 创建一个数据库1createdb kongdb 3.8.1 如果出现类似createdb: 无法联接到数据库 template1: 无法联接到服务器: 没有那个文件或目录 服务器是否在本地运行并且在 Unix 域套接字 “/var/run/postgresql/.s.PGSQL.5432”上准备接受联接?的错误则切回ubuntu的登录用户，执行下列操作1234$ sudo service postgresql start$ sudo systemctl unmask postgresql$ sudo systemctl restart postgresql$ sudo service postgresql start 3.9 创建角色（这里我在psql工具中创建一直不成功不知为啥，所以用sql来创建）1create user kong 3.10 通过postgresql的客户端来实现1psql 3.11 为”kong”用户设置密码1\\password 123456 3.12 把数据库 kongdb的所有者设置为 kong1alter database kongdb owner to kong 3.13 介绍一下一些基本的命令1234\\help 查看psql工具的命令\\q 退出\\du 查看所有用户（刚才创建后用这个查一下）\\l 查看所有数据库（同上） 3.14 用 \\q 命令退出并用kong用户登录kongdb数据库1psql -d kongdb -U kong -h 127.0.0.1 -W 3.15 这时会提示输入密码，输入刚才设置的123456即可 4、为kong配置数据源，找到/usr/local/share/lua/5.1/kong/templates/中的kong_defaults.lua，将里面的pg_pssword = NONE改为刚才设置的123456，pg_database = kong改为刚才创建的kongdb，如果无意外的话，这里可以启动kong了1$ sudo kong start 5、查阅官网kong的api操作，不同版本可能参数不同，这里以0.10.x版本为例，详见： https://getkong.org/docs/0.10.x/getting-started/adding-your-api/6、安装curl，如果已经装过git可能会有冲突，我这里就遇到了，记录一下1$ sudo apt-get install curl 6.1 报错1curl : 依赖: libcurl3-gnutls (= 7.47.0-1ubuntu2) 但是 7.47.0-1ubuntu2.2 正要被安装 6.2 一开始不清楚原因，执行了$ sudo apt-get update，出现了如下错误12E: 无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用) E: 无法对目录 /var/lib/apt/lists/ 加锁 6.3 解决方法，强制删除123$ sudo rm /var/cache/apt/archives/lock$ sudo rm /var/lib/dpkg/lock 6.4 6.3、6.4两个操作其实是没必要的，只是作为记录这里说说6.1的问题，重新安装 sudo apt-get install libcurl3-gnutls是没用的，这里是包冲突，需要指定版本来安装1$ sudo apt-get install libcurl3-gnutls=7.47.0-1ubuntu2 6.5 安装完后再执行一下$ sudo apt-get install curl即可 7、将业务侧的api加到kong中1curl -i -X POST --url http://localhost:8001/apis/ --data &apos;name=test&apos; --data &apos;upstream_url=http://192.168.0.1:8080/&apos; --data &apos;uris=/&apos; 7.1 这里需要说明，根据官网/apis/接口request body参数说明中，hosts、uris、methods需要至少指定一个，不赘述7.2 name指的是在kong api中的一个名字标识，具有唯一性，这里创建了test后，不允许再创建同名，若上方命令执行两次会报错7.3 可以到/usr/local/kong/logs中查看日志 8、然后就可以用kong来转发请求了，在https://getkong.org/docs/0.10.x/getting-started/adding-your-api/中有这么一句：1Issue the following cURL request to verify that Kong is properly forwarding requests to your API. Note that by default Kong handles proxy requests on port :8000 所以这里可以用 http://localhost:8000/ + 资源的方法访问http://192.168.0.1:8080/ 下所有的资源 9、Kong的一个非常诱人的地方就是提供了大量的插件来扩展应用，通过设置不同的插件可以为服务提供各种增强的功能。执行下面命令可以查看kong的所有插件1curl -i -X GET --url http://localhost:8001/plugins/enabled 9.1 用Rate Limiting来控制访问访问次数1curl -i -X POST --url http://localhost:8001/apis/test/plugins/ --data &quot;name=rate-limiting&quot; --data &quot;config.minute=5&quot; 接着随访找一个接口连续访问6次，如 http://localhost:8000/test 这个接口，第6次的时候就会提示 {“message”: “API rate limit exceeded”}9.2 另外kong集成了Galileo和Datadog，只要有账号就可以监控一些数据，具体到各自官网了解详情，另外Runscope是收费的，没有试过。","tags":[{"name":"kong","slug":"kong","permalink":"http://yoursite.com/tags/kong/"}]},{"title":"springboot+rabbitmq简单使用","date":"2017-05-27T03:40:31.000Z","path":"2017/05/27/springboot+rabbitmq简单使用/","text":"搭建springboot的时候比较喜欢用多模块管理，所以先新建一个父maven程序，select archetype时选择maven-archetype-site-simple，创建完后，pom.xml如下123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;per.example.mq&lt;/groupId&gt; &lt;artifactId&gt;example-mq-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;example-mq-parent&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--如果要把springboot工程打包成war执行，需要该jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-legacy&lt;/artifactId&gt; &lt;version&gt;1.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 到此父maven就完成，把项目下的src文件夹删了，具体看实际需求在父maven项目上右键新建maven module，选择maven-archetype-webapp创建一个web项目，完成，这里都是以eclipse为例，子maven的pom.xml如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\"?&gt;&lt;project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;per.example.mq&lt;/groupId&gt; &lt;artifactId&gt;example-mq-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;example-mq-server&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;example-mq-server Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;!-- 项目编码配置 start --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- 项目编码配置 end --&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 要使用LOG4J，去掉该依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 使用log4j，不使用默认的logback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 要打成war包执行，需要该依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-legacy&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 要打成war包执行，去掉内嵌的tomcat --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 引入mq包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;sq580-mq-server&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 先创一个简单的app来测试springboot启动有没有问题，在最外层的包目录下创建一个Application.java类，必须在外层，如pre.example.mq路径下创建12345678910111213141516171819package pre.example.mq;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.context.web.SpringBootServletInitializer;@SpringBootApplicationpublic class Application extends SpringBootServletInitializer &#123; protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Application.class); &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 在pre.example.mq路径下创建一个controller包，然后创建一个TestController.Java1234567891011121314151617181920212223242526package pre.example.mq.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import pre.example.mq.mq.data.service.MqSendService;@Controller@EnableAutoConfigurationpublic class TestController &#123; @Autowired private MqSendService mqSendService; @RequestMapping(\"/test\") @ResponseBody String test() &#123; // 这个再这里暂时还没有用，可以先注释 mqSendService.sendBindMsg(); return \"success\"; &#125; &#125; 完成，点击项目执行Run As - Java Application也可以，直接像普通的web项目在tomcat下启动也可以，如果8080端口被占，前者要在配置里修改访问端口，后者跟平常使用无异，springboot还可以配置彩色日志，为了快速开发，此处都不赘述，启动后会看到类似下方的界面1234567891011121314151617181920212223242526272829303132333435363738 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.3.5.RELEASE)[2017-05-27 10:57:23.677] boot - 9464 INFO [localhost-startStop-1] --- Application: Starting Application on Yangshaokun-PC with PID 9464 (E:\\apache-tomcat-7.0.67\\webapps\\wtpwebapps5\\sq580-mq-server\\WEB-INF\\classes started by Yangshaokun in E:\\eclipse)[2017-05-27 10:57:23.679] boot - 9464 INFO [localhost-startStop-1] --- Application: The following profiles are active: develop[2017-05-27 10:57:23.744] boot - 9464 INFO [localhost-startStop-1] --- AnnotationConfigEmbeddedWebApplicationContext: Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@294536ae: startup date [Sat May 27 10:57:23 CST 2017]; root of context hierarchy[2017-05-27 10:57:25.200] boot - 9464 INFO [localhost-startStop-1] --- PostProcessorRegistrationDelegate$BeanPostProcessorChecker: Bean &apos;org.springframework.amqp.rabbit.annotation.RabbitBootstrapConfiguration&apos; of type [class org.springframework.amqp.rabbit.annotation.RabbitBootstrapConfiguration$$EnhancerBySpringCGLIB$$4d0a742a] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)[2017-05-27 10:57:25.239] boot - 9464 INFO [localhost-startStop-1] --- [/sq580-mq-server]: Initializing Spring embedded WebApplicationContext[2017-05-27 10:57:25.239] boot - 9464 INFO [localhost-startStop-1] --- ContextLoader: Root WebApplicationContext: initialization completed in 1496 ms[2017-05-27 10:57:25.710] boot - 9464 INFO [localhost-startStop-1] --- TomcatWebSocketContainerCustomizer: NonEmbeddedServletContainerFactory detected. Websockets support should be native so this normally is not a problem.[2017-05-27 10:57:26.017] boot - 9464 INFO [localhost-startStop-1] --- ServletRegistrationBean: Mapping servlet: &apos;dispatcherServlet&apos; to [/][2017-05-27 10:57:26.018] boot - 9464 INFO [localhost-startStop-1] --- FilterRegistrationBean: Mapping filter: &apos;errorPageFilter&apos; to: [/*][2017-05-27 10:57:26.018] boot - 9464 INFO [localhost-startStop-1] --- FilterRegistrationBean: Mapping filter: &apos;characterEncodingFilter&apos; to: [/*][2017-05-27 10:57:26.019] boot - 9464 INFO [localhost-startStop-1] --- FilterRegistrationBean: Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*][2017-05-27 10:57:26.019] boot - 9464 INFO [localhost-startStop-1] --- FilterRegistrationBean: Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*][2017-05-27 10:57:26.019] boot - 9464 INFO [localhost-startStop-1] --- FilterRegistrationBean: Mapping filter: &apos;requestContextFilter&apos; to: [/*][2017-05-27 10:57:26.122] boot - 9464 INFO [localhost-startStop-1] --- AmqpConfig: recieveQueue:dataToCare_defaultrabbitmqIp:112.74.209.184:5672[2017-05-27 10:57:26.361] boot - 9464 INFO [localhost-startStop-1] --- RequestMappingHandlerAdapter: Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@294536ae: startup date [Sat May 27 10:57:23 CST 2017]; root of context hierarchy[2017-05-27 10:57:26.473] boot - 9464 INFO [localhost-startStop-1] --- RequestMappingHandlerMapping: Mapped &quot;&#123;[/test]&#125;&quot; onto java.lang.String com.sq580.mq.controller.TestController.one()[2017-05-27 10:57:26.481] boot - 9464 INFO [localhost-startStop-1] --- RequestMappingHandlerMapping: Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)[2017-05-27 10:57:26.481] boot - 9464 INFO [localhost-startStop-1] --- RequestMappingHandlerMapping: Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)[2017-05-27 10:57:26.514] boot - 9464 INFO [localhost-startStop-1] --- SimpleUrlHandlerMapping: Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler][2017-05-27 10:57:26.514] boot - 9464 INFO [localhost-startStop-1] --- SimpleUrlHandlerMapping: Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler][2017-05-27 10:57:26.559] boot - 9464 INFO [localhost-startStop-1] --- SimpleUrlHandlerMapping: Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler][2017-05-27 10:57:26.988] boot - 9464 INFO [localhost-startStop-1] --- AnnotationMBeanExporter: Registering beans for JMX exposure on startup[2017-05-27 10:57:26.998] boot - 9464 INFO [localhost-startStop-1] --- DefaultLifecycleProcessor: Starting beans in phase -2147482648[2017-05-27 10:57:26.998] boot - 9464 INFO [localhost-startStop-1] --- DefaultLifecycleProcessor: Starting beans in phase 2147483647[2017-05-27 10:57:27.156] boot - 9464 INFO [SimpleAsyncTaskExecutor-1] --- CachingConnectionFactory: Created new connection: SimpleConnection@35b4193e [delegate=amqp://openapi@112.74.209.184:5672/openapi][2017-05-27 10:57:27.346] boot - 9464 INFO [localhost-startStop-1] --- Application: Started Application in 4.331 seconds (JVM running for 7.63)[2017-05-27 10:57:27.359] boot - 9464 INFO [main] --- Http11AprProtocol: Starting ProtocolHandler [&quot;http-apr-9094&quot;][2017-05-27 10:57:27.374] boot - 9464 INFO [main] --- AjpAprProtocol: Starting ProtocolHandler [&quot;ajp-apr-8049&quot;][2017-05-27 10:57:27.375] boot - 9464 INFO [main] --- Catalina: Server startup in 6336 ms 看到这里没有报错就说明成功了，下面开始来配置mq，mq的选择可以自己查询资料做对比，此处以rabbitmq为例，在子maven中要引入包，见pom.xml，在src/main/resources目录下创建一个application.yml或者properties文件，这里以yml为例123456789101112131415161718spring: profiles.active: develop---spring: profiles: develop output: ansi: enabled: detect rabbitmq: ip: 你的mq服务器ip:5672 user: guest password: guest virtualHost: myhost app: reciveQueue: xxx(队列名)--- 这样准备工作就做完了，mq的工作流程、原理、搭建此处不赘述，上官网下一个mq包，解压，运行即可，跟redis类似，上述配置文件中的output.ansi.enabled是开启彩色日志的。首先，在pre.example.mq路径下创建config包，再创建一个AmqpConfig.java，如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package pre.example.mq.config;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.core.AcknowledgeMode;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;import org.springframework.amqp.rabbit.connection.ConnectionFactory;import org.springframework.amqp.rabbit.core.ChannelAwareMessageListener;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;import org.springframework.beans.factory.annotation.Value;import org.springframework.beans.factory.config.ConfigurableBeanFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Scope;import com.rabbitmq.client.Channel;@Configurationpublic class AmqpConfig &#123; private final static Logger LOG = LoggerFactory.getLogger(AmqpConfig.class); @Value(\"$&#123;rabbitmq.app.reciveQueue&#125;\") private String recieveQueue; @Value(\"$&#123;rabbitmq.ip&#125;\") private String rabbitmqIp; @Value(\"$&#123;rabbitmq.user&#125;\") private String rabbitmqUser; @Value(\"$&#123;rabbitmq.password&#125;\") private String rabbitmqPassword; @Value(\"$&#123;rabbitmq.virtualHost&#125;\") private String virtualHost; public static final String EXCHANGE = \"spring-boot-exchange\"; /** * 不管是发送端还是接收端，都需要创建这个 */ @Bean public ConnectionFactory connectionFactory() &#123; CachingConnectionFactory connectionFactory = new CachingConnectionFactory(); connectionFactory.setAddresses(rabbitmqIp); connectionFactory.setUsername(rabbitmqUser); connectionFactory.setPassword(rabbitmqPassword); connectionFactory.setVirtualHost(virtualHost); // 如果不设置这个，默认在根目录 connectionFactory.setPublisherConfirms(true); // 显示调用，才能进行消息的回调。 return connectionFactory; &#125; /** * 发送者发送消息需要RabbitTemplate提供api，此处消费者不需要 */ @Bean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // 最好为prototype类型 public RabbitTemplate rabbitTemplate() &#123; RabbitTemplate template = new RabbitTemplate(connectionFactory()); return template; &#125; /** * 针对消费者配置 1. 设置交换机类型 2. 将队列绑定到交换机 FanoutExchange: * 将消息分发到所有的绑定队列，无routingkey的概念 HeadersExchange ：通过添加属性key-value匹配 * DirectExchange:按照routingkey分发到指定队列 TopicExchange:多关键字匹配 */ @Bean public TopicExchange defaultExchange() &#123; return new TopicExchange(EXCHANGE); &#125; @Bean public Queue queue() &#123; return new Queue(recieveQueue, true); // 队列持久 &#125; /** * 这里有必要记录一下，这里queue跟exchange绑定了， * 也就是生产者发消息到该exchange后， * exchange会根据routingKey关键字发送到符合规则的queue中去， * 如果不符合则丢弃，如果上rabbitmq的管理后台看的话可以看到即便项目关闭， * exchang和queue还是存在绑定关系，看到defaultExchange()方法中， * 创建的topicExchange使用了spring-boot-exchange这个名字， * 如果临时想换个类型的交换机，则需要使用不同的exchang名字， * 不然的话会报错，或者直接到管理后台把exchang或删了 */ @Bean public Binding binding() &#123; // 绑定队列到交换机中，并使用关键字匹配，后面会讲到关键字的匹配 return BindingBuilder.bind(queue()).to(defaultExchange()) .with(\"info.red.#\"); &#125; /** * 消费者接收消息并作出应答，确保消息不会因为消费者的奔溃而被丢弃 */ @Bean public SimpleMessageListenerContainer messageContainer() &#123; LOG.info(\"recieveQueue:\" + recieveQueue + \"rabbitmqIp:\" + rabbitmqIp); SimpleMessageListenerContainer container = new SimpleMessageListenerContainer( connectionFactory()); container.setQueues(queue()); container.setExposeListenerChannel(true); container.setMaxConcurrentConsumers(1); container.setConcurrentConsumers(1); container.setAcknowledgeMode(AcknowledgeMode.MANUAL); // 设置确认模式手工确认 container.setMessageListener(new ChannelAwareMessageListener() &#123; @Override public void onMessage(Message message, Channel channel) throws Exception &#123; byte[] body = message.getBody(); LOG.info(\"receive msg : \" + new String(body)); System.out.println(\"receive msg : \" + new String(body)); try &#123; channel.basicAck(message.getMessageProperties() .getDeliveryTag(), false); // 确认消息成功消费 &#125; catch (Exception e) &#123; LOG.error(\"消费队列失败:\" + \"\", e); // 重试一次 channel.basicNack(message.getMessageProperties() .getDeliveryTag(), false, false); &#125; &#125; &#125;); return container; &#125;&#125; 打开TestController中的service调用，创建一个service，如1234567891011121314151617181920212223242526package pre.example.mq.mq.data.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import pre.example.mq.mq.MessageProducer;@Servicepublic class MqSendService &#123; @Autowired private MessageProducer messageProducer; /** * @Title: sendMsg * @Description: 发送消息 */ public void sendMsg()&#123; messageProducer.sendMessage(\"info.red.a\"); messageProducer.sendMessage(\"info.red.b\"); messageProducer.sendMessage(\"info.black.a\"); messageProducer.sendMessage(\"err.red.a\"); messageProducer.sendMessage(\"info.red.a.a\"); &#125;&#125; MessageProducer.java123456789101112131415161718192021222324252627282930313233343536373839404142package pre.example.mq.mq;import javax.annotation.Resource;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.stereotype.Service;import pre.example.mq.config.AmqpConfig;@Servicepublic class MessageProducer &#123; private final static Logger LOG = LoggerFactory.getLogger(MessageProducer.class); @Resource private AmqpTemplate rabbitTemplate; /*public void setRabbitTemplate(RabbitTemplate rabbitTemplate) &#123; // amqp 1.3.5之前版本需要显示设置消息确认，无法直接使用AmqpTemplate，需要使用RabbitTemplate this.rabbitTemplate = rabbitTemplate; this.rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback()&#123; @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; if (ack) &#123; System.out.println(\"消息确认成功\"); &#125; else &#123; //处理丢失的消息（nack） System.out.println(\"消息确认失败\"); &#125; &#125; &#125;); &#125;*/ public void sendMessage(Object message) &#123; LOG.debug(\"to send message:&#123;&#125;\", message); try &#123; rabbitTemplate.convertAndSend(AmqpConfig.EXCHANGE, message.toString(), message); &#125; catch (Exception e) &#123; LOG.error(\"发送队列消息错：\" + \"\", e); &#125; &#125;&#125; 发送者很简单，这里我们通过接口访问的形式，调用了MessageProducer的sendMessage方法，rabbitTemplate.convertAndSend是发送消息的调用，第一个参数表示交换机，使用mq的订阅功能并不需要理会queue，只需要指定交换机，这里的交换机需要跟消费者一样；第二个参数是关键字匹配，如这里发送了5条消息，关键字如下12345messageProducer.sendMessage(&quot;info.red.a&quot;);messageProducer.sendMessage(&quot;info.red.b&quot;);messageProducer.sendMessage(&quot;info.black.a&quot;);messageProducer.sendMessage(&quot;err.red.a&quot;);messageProducer.sendMessage(&quot;info.red.a.a&quot;); 看到AmqpConfig.java类的binding方法，那里消费者匹配了info.red.#方法，*表示匹配一个，#表示匹配多个，所以这里发送的5条消息，只有1、2、4会被接收到，如果是info.red.* 则只有1、2会被接收。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"mq","slug":"mq","permalink":"http://yoursite.com/tags/mq/"}]},{"title":"AOP拦截Controller处理@RequestBody注入参数问题","date":"2017-05-03T09:24:26.000Z","path":"2017/05/03/AOP拦截Controller/","text":"问题： 使用springMVC，一些请求前的校验，都可以在拦截器或者过滤器里做处理，处理完后到Controller层再根据喜好做相关操作，但是遇到content-type是application/json等放在body体里的就尴尬了，读完body，在Controller就无法再获取一次了，或许你可以把request的inputStream读出来缓存两份。但这要动根基了，不划算。另外，如果需要改变某个参数再由@RequestBody注入，又是一个尴尬的问题，可以把配置的Json处理写成自己的逻辑。但所有请求都经过这个也显得累赘。 键值形式的传参处理1234567891011121314151617181920212223242526272829303132package com.sq580.mall.order.web;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class XxxInterceptor implements Filter &#123; @Override public void destroy() &#123;&#125; @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) arg0; ServletRequest requestWrapper = new ParameterRequestWrapper(req); String body = HttpHelper.getBodyString(requestWrapper); System.out.println(body); // 自己拦截的逻辑 arg2.doFilter(requestWrapper, (HttpServletResponse) arg1); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123;&#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xxx;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.nio.charset.Charset;import java.util.Enumeration;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;public class ParameterRequestWrapper extends HttpServletRequestWrapper &#123; private final byte[] body; public ParameterRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); body = HttpHelper.getBodyString(request).getBytes(Charset.forName(\"UTF-8\")); &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; final ByteArrayInputStream bais = new ByteArrayInputStream(body); return new ServletInputStream() &#123; @Override public int read() throws IOException &#123; return bais.read(); &#125; &#125;; &#125; @Override public String getHeader(String name) &#123; return super.getHeader(name); &#125; @Override public Enumeration&lt;String&gt; getHeaderNames() &#123; return super.getHeaderNames(); &#125; @Override public Enumeration&lt;String&gt; getHeaders(String name) &#123; return super.getHeaders(name); &#125;&#125; HttpHelper工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.xxx;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.nio.charset.Charset;import javax.servlet.ServletRequest;public class HttpHelper &#123; /** * 获取请求Body * @param request * @return */ public static String getBodyString(ServletRequest request) &#123; StringBuilder sb = new StringBuilder(); InputStream inputStream = null; BufferedReader reader = null; try &#123; inputStream = request.getInputStream(); reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(\"UTF-8\"))); String line = \"\"; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return sb.toString(); &#125;&#125; web.xml12345678&lt;filter&gt; &lt;filter-name&gt;requestFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.xxx.XxxInterceptor&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;requestFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; body传参处理 使用aop来切Controller中的方法，这时参数已经注入了，不存在重复读request流的问题注意： 这里开启aop的配置需要写在springmvc中，不能写在spring的applicationContext.xml中，两者有所区别12&lt;aop:aspectj-autoproxy proxy-target-class=\"true\" /&gt;&lt;context:component-scan base-package=\"com.xxx\" /&gt; 切面的使用，注意要扫包12345678910111213141516171819202122232425262728293031@Aspect@Componentpublic class PariseAspect &#123; // 第一个*表示所有返回类型，第二段是com.xxx包下任何包的所有后缀为Controller的类的所有方法，(..)表示方法所带任何参数 @Pointcut(\"execution(* com.xxx.*.*Controller.*(..))\") public void controllerAspect() &#123;&#125; // @Before是指在方法执行前执行，@After指在方法执行后执行，这两个都好理解，@Around并不是在方法执行过程循环执行，它表示的是 /* &#123; // before // 你可以让它继续执行，也可以返回，是这么一种环绕意义，有点类似过滤器 // after &#125;*/ @Around(\"controllerAspect()\") public Object checkToken(ProceedingJoinPoint point) &#123; // 获取所有参数，自己断点可以理解清楚点，一般第一个为@RequestBody所注入的对象，第二个为BindingResult，假设对象中有个userId，此处改变了对象的值后，通知继续执行 Object[] args = point.getArgs(); Class clazz = args[0].getClass(); Method m = clazz.getDeclaredMethod(\"setUserId\", Long.class); if (null != m) &#123; m.invoke(arg, 1L); args[1] = arg; &#125; else &#123; // 返回错误 return \"error.jsp\"; &#125; return point.proceed(args); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"使用redis维护token","date":"2017-05-03T09:23:40.000Z","path":"2017/05/03/使用redis维护token/","text":"用redis维护token的思路：存入12345678// 生成tokenString token = UUID.randomUUID().toString();// 将对象转为Json串String json = JacksonUtils.newInstance().obj2json(user);// 以token为key，对象为value缓存到redisjedisUtils.set(token, json, 120 * 60);// 将userId - token以key - value的形式放入到一个hash表中，这里最好遵循标准的命名规则：（项目：模块：形式）jedisUtils.hset(\"project:sso:uid_token\", \"project:sso:\".concat(user.getUserId()), token); 校验123456789101112131415161718192021222324String token = request.getHeader(\"token\");if(null != token &amp;&amp; StringUtils.isNotBlank(token)) &#123; // 获取key为token的对象，并续租token String objJson = jedisUtils.get(token, 120 * 60); if (objJson != null &amp;&amp; StringUtils.isNotBlank(objJson)) &#123; // 获取对象 User user = JSON.parseObject(objJson, User.class); if (user != null) &#123; // 通过userid获取hash表中的token，并续租 String val = jedisUtils.get(key, 120 * 60); if (val.equals(token)) &#123; // 通过验证 &#125; else &#123; // 不通过验证 &#125; &#125; else &#123; // 不通过验证 &#125; &#125; else &#123; // 不通过验证 &#125;&#125; else &#123; // 提示需传token&#125; 如果只以键值的形式存储，会有以下几种问题：1、用户登录的时候重新分配了token，同一用户可重复登录2、也可以以uid-token的形式存储，每次登录判断token是否一致，但这种就无法简略到只传token了用hash配合的逻辑1、存一对token-user2、hash存uid-token3、每次接收token后拿到user，用uid去获取token4、比对两个token好处：B用户登录后，两个键值都改变了，A用户操作的时候用旧的token可以获取到user，但是hash中的token已经变了，所以验证不通过，因为设置了操作时效性，所以旧的token-user会在规定时间后失效，释放内存 附： jedisUtils工具类见【Java操作redis】文章","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"Java下载文件损坏问题","date":"2017-04-21T06:30:19.000Z","path":"2017/04/21/Java下载文件损坏问题/","text":"开发的过程中经常需要导出各种报表，生成表的过程此处不表。说说下载遇到的问题：下载可以分为2种，一种是将文件保存到某个位置，然后返回url让client进行访问下载，但大多数时候我们并不需要这些文件，这个时候就浪费了磁盘空间，即便后面做了清理，也是比较不友好的一种情况。所以我们一般都是直接以流的形式将文件传给client12345678910111213141516171819202122@RequestMapping(\"/export\")public ResponseEntity&lt;byte[]&gt; export() &#123; byte[] body = null; String url = \"你的资源文件url\"; HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection(); // 不管你是读本地文件，网络文件还是Workbook等等，这里以网络文件为例 InputStream in = conn.getInputStream(); body = new byte[in.available()]; in.read(body); HttpHeaders headers = new HttpHeaders(); // 响应头的名字和响应头的值 headers.add(\"Content-Disposition\", \"attachment;filename=\" + \"文件名，要加后缀\"); HttpStatus statusCode = HttpStatus.OK; ResponseEntity&lt;byte[]&gt; response = new ResponseEntity&lt;byte[]&gt;(body, headers, statusCode); return response; &#125; 以上的方法可以基本满足下载的功能，但是我在实际开发中导出excel文件，发现下载的Excel文件打开的时候已经损坏了，本来是读取HSSFWorkbook直接返回的，为了方便排查，把生成的excel保存在了本地再执行响应，发现本地的excel打开是正常的，而下载后的却是损坏的，后来查阅了资料发现，如果一次性将流转为byte可能会有丢失问题，于是改用如下方式，将流先缓存包装起来，再返回，通过。修改代码如下12345678910111213141516171819HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();InputStream in = conn.getInputStream(); ByteArrayOutputStream swapStream = new ByteArrayOutputStream(); byte[] buff = new byte[1024]; int len = 0; while ((len = in.read(buff, 0, 100)) &gt; 0) &#123; swapStream.write(buff, 0, len); &#125; byte[] body = swapStream.toByteArray(); HttpHeaders headers = new HttpHeaders();// 响应头的名字和响应头的值headers.add(\"Content-Disposition\", \"attachment;filename=\" + fileName); HttpStatus statusCode = HttpStatus.OK; ResponseEntity&lt;byte[]&gt; response = new ResponseEntity&lt;byte[]&gt;(body, headers, statusCode);return response;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring boot的入门使用","date":"2017-01-24T08:25:49.000Z","path":"2017/01/24/Spring boot的入门使用/","text":"pom.xml的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;test&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;test&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 若已经有父项目依赖，则在父项目中添加如下代码 --&gt; &lt;!-- &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; Import dependency management from Spring Boot &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.2.3.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;!-- 项目编码配置 start --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- 项目编码配置 end --&gt; &lt;!-- 依赖的jar的版本号控制 start --&gt; &lt;!-- 依赖的jar的版本号控制 end --&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 核心模块，包括自动配置支持、日志和YAML --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试模块，包括JUnit、Hamcrest、Mockito --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Web模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;version&gt;1.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;!-- 热部署配置 --&gt; &lt;jvmArguments&gt; -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005 &lt;/jvmArguments&gt; &lt;!-- spring-boot 默认使用1.6，若使用其它版本，需要指定好相应版本 --&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; model类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package per.test.mdoel;/** * @Title: User.java * @Package per.test.mdoel * @Description: 用户实体类 * @author zoro * @date 2017年1月22日 下午5:09:58 */public class User &#123; private Long id; private String name; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; User other = (User) obj; if (id == null) &#123; if (other.id != null) return false; &#125; else if (!id.equals(other.id)) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; @Override public String toString() &#123; return \"User [id=\" + id + \", name=\" + name + \"]\"; &#125;&#125; Controller类1234567891011121314151617181920212223242526272829303132333435package per.test.controller;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;import org.springframework.context.annotation.Bean;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import per.test.mdoel.User;/** * @Title: UserController.java * @Package per.test.controller * @Description: 用户请求控制类 * @author zoro * @date 2017年1月22日 下午5:31:52 * pre: * @Controller + @EnableAutoConfiguration = @RestController */@RestController@RequestMapping(\"/user\")public class UserController &#123; @RequestMapping(\"/&#123;id&#125;\") public User view(@PathVariable(\"id\") Long id) &#123; User user = new User(); user.setId(id); user.setName(\"zhang\"); return user; &#125; &#125; 运行12345678910111213141516171819202122package per.test;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @Title: UserController.java * @Package per.test.controller * @Description: 用户请求控制类 * @author zoro * @date 2017年1月22日 下午5:33:01 * pre: * @SpringBootApplication继承了 @Configuration、 @EnableAutoConfiguration、 @ComponentScan */@SpringBootApplicationpublic class AppTest &#123; public static void main(String[] args) &#123; SpringApplication.run(AppTest.class); &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Srping boot","slug":"Srping-boot","permalink":"http://yoursite.com/tags/Srping-boot/"}]},{"title":"maven打包可执行项目","date":"2017-01-17T07:25:49.000Z","path":"2017/01/17/maven打包可执行项目/","text":"pom.xml配置123456789101112131415161718192021222324252627282930&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- 项目主清单（main）入口类 --&gt; &lt;mainClass&gt;com.test.TestMain&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptors&gt; &lt;!-- 因为不是web程序，所以需要另外增加assmbly.xml文件 --&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; assmbly.xml（放在pom.xml同目录下）文件配置如下：1234567891011121314151617181920&lt;assembly xmlns=\"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd\"&gt; &lt;id&gt;uberjar&lt;/id&gt; &lt;formats&gt; &lt;format&gt;jar&lt;/format&gt; &lt;/formats&gt; &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;!-- 引用的第三方jar包是否解压，如果为true，则解压第三方jar包为单独的文件目录；如果为false，则是将第三方jar包打进工程jar包下 --&gt; &lt;unpack&gt;true&lt;/unpack&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt; &lt;fileSets&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.build.outputDirectory&#125;&lt;/directory&gt; &lt;outputDirectory&gt;/&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;/fileSets&gt;&lt;/assembly&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"maven引用外部jar包","date":"2017-01-17T07:20:15.000Z","path":"2017/01/17/maven引用外部jar包/","text":"从路径读取jar的方式，比较好的做法是在项目中建一个lib目录来存放jar包123456789&lt;dependency&gt; &lt;groupId&gt;postmsg-ump&lt;/groupId&gt; &lt;artifactId&gt;postmsg-ump&lt;/artifactId&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;!-- 版本随便，为了好管理从1.0开始写，我这里已经迭代很多了 --&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;!-- basedir表示根目录，如果不在项目中则写绝对路径，如d:\\\\postmsg-ump-2.4.jar --&gt; &lt;systemPath&gt;$&#123;basedir&#125;\\src\\lib\\postmsg-ump-2.4.jar&lt;/systemPath&gt;&lt;/dependency&gt; 也可以用命令的方式将jar包导入本地仓库1mvn install:install-file -DgroupId=postmsg-ump -DartifactId=postmsg-ump -Dversion=2.4 -Dpackaging=jar -Dfile=d:\\postmsg-ump-2.4.jar -Dfile表示要加入仓库的jar包路径，执行命令后，在pom.xml中则不需要system和systemPath这两项了，但是不推荐使用这种方式，因为实际开发的过程中常需要协同开发，当把项目提交到代码库，从另一个地方把项目check out的之后，发现少了包 最好的方法也是推荐的方法是建立一个共享私库，比如nexus","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"SpringMvc整合Swagger UI","date":"2017-01-14T01:48:05.000Z","path":"2017/01/14/SpringMvc整合Swagger UI/","text":"首先，导入主要的jar包1234567891011121314151617&lt;!-- swagger-springmvc start --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mangofactory&lt;/groupId&gt; &lt;artifactId&gt;swagger-springmvc&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.mangofactory&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.wordnik&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;version&gt;1.3.11&lt;/version&gt;&lt;/dependency&gt;&lt;!-- swagger-springmvc end --&gt; 定义一个config类来实现swagger的配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package test.util;import java.util.List;import javax.inject.Inject;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import com.mangofactory.swagger.configuration.SpringSwaggerConfig;import com.mangofactory.swagger.models.dto.ApiInfo;import com.mangofactory.swagger.plugin.EnableSwagger;import com.mangofactory.swagger.plugin.SwaggerSpringMvcPlugin;@Configuration@EnableWebMvc@EnableSwaggerpublic class SwaggerConfig &#123; private SpringSwaggerConfig springSwaggerConfig; public SpringSwaggerConfig getSpringSwaggerConfig() &#123; return springSwaggerConfig; &#125; @Inject public void setSpringSwaggerConfig(SpringSwaggerConfig springSwaggerConfig) &#123; this.springSwaggerConfig = springSwaggerConfig; &#125; @Bean public SwaggerSpringMvcPlugin customImplementation() &#123; return new SwaggerSpringMvcPlugin (this.springSwaggerConfig) .apiInfo(apiInfo()) .includePatterns(\".*?\"); &#125; private ApiInfo apiInfo() &#123; ApiInfo apiInfo = new ApiInfo( \"系统管理平台API\", \"\", \"\", \"\", \"\", \"\"); return apiInfo; &#125;&#125; 在网上可能会看到@WebAppConfiguration配置，那是测试时候用的，发布的时候需要用@Configuration代替，@Configuration等价于xml里的beans标签，@EnableWebMvc注解驱动，将@RequestMapping的传入请求映射到一定的方法@Controller -annotated类的支持，@EnableSwagger自动注入SpringSwaggerConfig 上面的代码写完后springSwaggerConfig可能是null，因为还没有注入，有可能是@EnableSwagger没被扫到，也有可能是无效，加上以下配置1&lt;bean class=\"com.mangofactory.swagger.configuration.SpringSwaggerConfig\" /&gt; 也有可能没有报错，就是启动的时候并没有把Controller中的url管理起来，原因是需要在启动时注入我们自己写的配置，加入以下代码1234&lt;!-- swaggerUI 开始 --&gt;&lt;mvc:annotation-driven/&gt;&lt;bean class=\"test.SwaggerConfig\"&gt;&lt;/bean&gt;&lt;!-- swaggerUI 结束 --&gt; 有如下的几种使用方式123456789@Api(value = \"/user\", description = \"用户操作接口\", position = 1) @ApiOperation(value = \"/user/getdetail\", httpMethod = \"POST\", notes = \"获取用户详细信息\", response = DetailResponseVo.class)@ApiResponses(value = &#123; @ApiResponse(code = 200, message = \"操作成功！\", response = DetailResponseVo.class), @ApiResponse(code = 404, message = \"找不到页面\"), @ApiResponse(code = 500, message = \"内部报错\")&#125;)@ApiModel(value = \"用户信息\")@ApiModelProperty(value = \"用户id\") 说明123456@Api表示一个开放的API，简要描述该API的功能。在一个@API下，可有多个@ApiOperation，表示针对该API的CRUD操作。在ApiOperation Annotation中可以通过value，notes描述该操作的作用，response描述正常情况下该请求的返回对象类型。在一个ApiOperation下，可以通过ApiResponses描述该API操作可能出现的情况。@ApiParam用于描述该API操作接受的参数类型@ApiModel用在类上@ApiModelProperty用在类中的属性上 展示 Swagger-UI下载地址123456从github下载Swagger-UI, 解压后把该项目dist目录下的内容拷贝到自己的项目中，最好在webapp下建一个swagger目录来存放，编辑swagger/index.html文件，找到url = &quot;http://petstore.swagger.io/v2/swagger.json&quot;;这一句，修改为url = &quot;/projectName/api-docs&quot;;projectName是指自己的项目名字；也可以写成http://&#123;ip&#125;:&#123;port&#125;/&#123;projectName&#125;/api-docs这个格式 因为springMvc会拦截静态资源，所以还需加上下面的过滤配置1&lt;mvc:resources mapping=\"/swagger/**\" location=\"/swagger/\"/&gt; 打开浏览器直接访问swagger目录下的index.html文件即可，如1http://localhost:8080/projectName/swagger/index.html","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"http://yoursite.com/tags/SpringMvc/"},{"name":"api","slug":"api","permalink":"http://yoursite.com/tags/api/"}]},{"title":"POI导出excel表","date":"2017-01-03T09:06:39.000Z","path":"2017/01/03/POI导出excel表/","text":"列标题属性注解类123456789101112131415161718192021222324252627282930313233343536373839404142434445package excel;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.apache.poi.hssf.util.HSSFColor;import org.apache.poi.ss.usermodel.CellStyle;/** * @Title: ExcelAnnotation.java * @Package excel * @Description: 列标题属性注解 * @author Zoro * @date 2016年12月30日 下午4:13:54 * @version V1.0 */@Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.FIELD&#125;)public @interface ExcelAnnotation &#123; // 列标题名 public String name() default \"\"; // 行号 public int col() default 0; // 日期格式 public String dateFormat() default \"\"; /** 列标题样式 start */ // 水平对齐（默认居中） public short alignment() default CellStyle.ALIGN_CENTER; // 垂直对齐（默认） public short verticalAlignment() default CellStyle.VERTICAL_CENTER; // 填充信息模式和纯色填充单元（默认不填充） public short fillPattern() default CellStyle.SOLID_FOREGROUND; // 背景色填充（默认白色） public short fillBackgroundColor() default HSSFColor.GREY_40_PERCENT.index; // 字号（默认16） public short fontHeighInPoints() default 16; // 字体颜色（默认黑色） public short fontColor() default HSSFColor.BLACK.index; /** 列标题样式 end */ &#125; Excel表格属性类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package excel;import java.io.File;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * @Title: ExcelArgs.java * @Package excel * @Description: Excel表格属性 * @author Zoro * @date 2016年12月30日 下午2:38:48 * @version V1.0 */public class ExcelArgs &#123; // 工作表 private List&lt;SheetArgs&gt; sheets = new ArrayList&lt;SheetArgs&gt;(); // 文件名 private String fileName; // 文件保存路径 private String filePath; // 完整路径+文件名 private String excelName; /** * @Title: init * @Description: 初始化excel * @param * @return void * @throws */ public void init() &#123; if (null == fileName || \"\".equals(fileName.trim())) &#123; throw new RuntimeException(\"Excel 文件名不能为空！\"); &#125; fileName = fileName.trim(); if (!(fileName.endsWith(\".xls\") || fileName.endsWith(\".xlsx\"))) &#123; // 设置默认文件后缀 fileName = fileName + \".xls\"; &#125; DateFormat df = new SimpleDateFormat(\"yyyyMMddHHmmss\"); fileName = df.format(new Date()) + \"_\" + fileName; if (null == filePath || \"\".equals(filePath.trim())) &#123; // 设置默认文件生成路径（生成的文件在项目的tmp目录下） filePath = \"src/main/webapp/tmp\"; &#125; if (!(filePath.endsWith(File.separator))) &#123; filePath += File.separator; &#125; &#125; public List&lt;SheetArgs&gt; getSheets() &#123; return sheets; &#125; public void setSheets(SheetArgs sheet)&#123; if(sheets==null)&#123; sheets = new ArrayList&lt;&gt;(); &#125; sheets.add(sheet); &#125; public String getFileName() &#123; return fileName; &#125; public void setFileName(String fileName) &#123; this.fileName = fileName; &#125; public String getFilePath() &#123; return filePath; &#125; public void setFilePath(String filePath) &#123; this.filePath = filePath; &#125; public String getExcelName() &#123; return filePath + fileName; &#125; public void setExcelName(String excelName) &#123; this.excelName = excelName; &#125; &#125; Sheet表格属性类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package excel;import java.util.List;import org.apache.poi.hssf.util.HSSFColor;import org.apache.poi.ss.formula.functions.T;import org.apache.poi.ss.usermodel.CellStyle;import org.apache.poi.ss.usermodel.IndexedColors;/** * @Title: SheetArgs.java * @Package excel * @Description: Sheet表格属性 * @author Zoro * @date 2016年12月30日 下午2:36:25 * @version V1.0 */@SuppressWarnings(\"hiding\")public class SheetArgs&lt;T&gt; &#123; // 工作表名 public String sheetName; // 标题名 public String titleName; // 注入类 public Class&lt;?&gt; clazz; // 数据源 public List&lt;T&gt; source; /** 标题样式 start */ // 标题从第几行开始（默认第一行） public int defaultRow = 0; // 标题从第几行结束（默认第一行） public int endRow = 0; // 标题从第几列开始（默认第一列） public int defaultCol = 0; // 标题从第几列结束（默认第一列到最大列数 ） public int endCol = 0; // 行高 public int heightInPoints = 40; // 默认列宽（默认25） public int defaultColumnWidth = 20; // 水平对齐（默认居中） public short alignment = CellStyle.ALIGN_CENTER; // 垂直对齐（默认） public short verticalAlignment = CellStyle.VERTICAL_CENTER; // 填充信息模式和纯色填充单元（默认全填充） public short fillPattern = CellStyle.SOLID_FOREGROUND; // 背景色填充（默认浅黄色） public short fillBackgroundColor = IndexedColors.LEMON_CHIFFON.index; // 字号（默认24） public short fontHeighInPoints = 24; // 字体颜色（默认黑色） public short fontColor = HSSFColor.BLACK.index; /** 标题样式 end*/ &#125; 报表导出数据属性类123456789101112131415161718192021222324252627282930313233package excel;/** * @Title: ExcelExport.java * @Package excel * @Description: 报表导出数据属性 * @author Zoro * @date 2016年12月30日 下午2:24:51 * @version V1.0 */public class ExcelExport implements Comparable&lt;ExcelExport&gt; &#123; public String name; public int order; public String dateFormat; public ExcelExport(String name, int order, String dateFormat) &#123; super(); this.name = name; this.order = order; this.dateFormat = dateFormat; &#125; @Override public int compareTo(ExcelExport o) &#123; return this.order - o.getOrder(); &#125; public int getOrder() &#123; return order; &#125;&#125; 报表操作工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package excel;import java.io.FileOutputStream;import java.lang.reflect.Field;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Collections;import java.util.List;import org.apache.poi.hssf.usermodel.HSSFFont;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.hssf.util.HSSFColor;import org.apache.poi.ss.formula.functions.T;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.CellStyle;import org.apache.poi.ss.usermodel.Font;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.util.CellRangeAddress;/** * @Title: ExcelUtil.java * @Package excel * @Description: 报表操作工具类 * @author Zoro * @date 2016年12月30日 下午3:05:19 * @version V1.0 */public class ExcelUtil &#123; /** * @throws SecurityException * @throws NoSuchFieldException * @Title: exportExcel * @Description: 导出报表 * @param * @return void * @throws */ public static String exportExcel(ExcelArgs excelArgs) throws Exception &#123; // 初始化存储路径 excelArgs.init(); // 声明一个工作薄 HSSFWorkbook workbook = new HSSFWorkbook(); // 获取所有工作表 List&lt;SheetArgs&gt; sheets = excelArgs.getSheets(); // 遍历所有工作表 for (SheetArgs sheet : sheets) &#123; createSheet(workbook, sheet); &#125; // 创建一个文件流 try(FileOutputStream fos = new FileOutputStream(excelArgs.getExcelName());) &#123; // 把内容写入流 workbook.write(fos); return excelArgs.getFileName(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * @throws SecurityException * @throws NoSuchFieldException * @Title: createSheet * @Description: 生成工作表 * @param @param workbook * @param @param sheet * @return void * @throws */ private static void createSheet(HSSFWorkbook workbook, SheetArgs mySheet) throws Exception, SecurityException &#123; // 创建工作表 Sheet sheet = workbook.createSheet(mySheet.sheetName); sheet.setDefaultColumnWidth(mySheet.defaultColumnWidth); Row row = null; Cell cell = null; int columnlength = 0; int rowNumber = 0; List&lt;ExcelExport&gt; sourceList = new ArrayList&lt;ExcelExport&gt;(); // 获取所有的属性 Field[] fields = mySheet.clazz.getDeclaredFields(); // 设置列标题行 if (null != fields &amp;&amp; fields.length &gt; 0) &#123; row = sheet.createRow(mySheet.endRow + 1); for (Field field : fields) &#123; ExcelAnnotation annotation = field.getAnnotation(ExcelAnnotation.class); if (annotation instanceof ExcelAnnotation) &#123; // 创建列 cell = row.createCell(mySheet.defaultCol + annotation.col()); // 设置列名样式 CellStyle titleStyle = workbook.createCellStyle(); titleStyle.setAlignment(annotation.alignment()); titleStyle.setVerticalAlignment(annotation.verticalAlignment()); titleStyle.setFillForegroundColor(annotation.fillBackgroundColor()); titleStyle.setFillPattern(annotation.fillPattern()); Font font = workbook.createFont(); font.setFontHeightInPoints(annotation.fontHeighInPoints()); font.setColor(annotation.fontColor()); font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); titleStyle.setFont(font); cell.setCellStyle(titleStyle); cell.setCellValue(annotation.name()); ExcelExport excelExport = new ExcelExport(field.getName(), annotation.col(), annotation.dateFormat()); sourceList.add(excelExport); columnlength++; &#125; &#125; &#125; // 排序列 Collections.sort(sourceList); // 设置总标题 if (null != mySheet.titleName &amp;&amp; !\"\".equals(mySheet.titleName.trim()))&#123; row = sheet.createRow(mySheet.defaultRow); cell = row.createCell(mySheet.defaultCol); row.setHeightInPoints(mySheet.heightInPoints); cell.setCellValue(mySheet.titleName); CellStyle titleStyle = workbook.createCellStyle(); titleStyle.setAlignment(mySheet.alignment); titleStyle.setVerticalAlignment(mySheet.verticalAlignment); titleStyle.setFillForegroundColor(mySheet.fillBackgroundColor); titleStyle.setFillPattern(mySheet.fillPattern); Font font = workbook.createFont(); font.setFontHeightInPoints(mySheet.fontHeighInPoints); font.setColor(mySheet.fontColor); titleStyle.setFont(font); cell.setCellStyle(titleStyle); // 合并单元格 if (0 == mySheet.endCol &amp;&amp; columnlength &gt; 0) &#123; mySheet.endCol = mySheet.defaultCol + columnlength - 1; &#125; sheet.addMergedRegion(new CellRangeAddress( mySheet.defaultRow, mySheet.endRow, mySheet.defaultCol, mySheet.endCol)); &#125; // 设置数据 List&lt;T&gt; datas = mySheet.source; rowNumber = mySheet.endRow + 2; if (null != datas &amp;&amp; !datas.isEmpty() &amp;&amp; 0 &lt; datas.size()) &#123; // 这个放循环里面的话实例Excel超过4000行会报错 CellStyle cellStyle = workbook.createCellStyle(); for (Object data : datas) &#123; row = sheet.createRow(rowNumber++); for (int i = 0; i &lt; columnlength; i++) &#123; ExcelExport excelExport = sourceList.get(i); cell = row.createCell(mySheet.defaultCol + i); Object source = null; String value = null; // 反射获取数据 Field field = mySheet.clazz.getDeclaredField(excelExport.name); field.setAccessible(true); source = field.get(data); // 单元格样式 cellStyle.setAlignment(CellStyle.ALIGN_CENTER); cellStyle.setVerticalAlignment(CellStyle.VERTICAL_CENTER); Font font = workbook.createFont(); font.setFontHeightInPoints((short) 12); font.setColor(HSSFColor.BLACK.index); cellStyle.setFont(font); cell.setCellStyle(cellStyle); value = null != source ? source.toString() : \"\"; if (null != excelExport.dateFormat &amp;&amp; !\"\".equals(excelExport.dateFormat)) &#123; value = new SimpleDateFormat(excelExport.dateFormat).format(source); sheet.setColumnWidth(mySheet.defaultCol + i, 36 * 256); &#125; cell.setCellValue(value); &#125; &#125; &#125; &#125;&#125; 测试要导出的数据源类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217package excel;import java.math.BigDecimal;import java.util.Date;/** * @Title: ExcelSource.java * @Package excel * @Description: 报表数据源 * @author Zoro * @date 2016年12月30日 下午2:33:36 * @version V1.0 */public class ExcelSource &#123; @ExcelAnnotation(name = \"账单id\", col = 0) private Long billingId; @ExcelAnnotation(name = \"账单号\", col = 1) private String billingNum; @ExcelAnnotation(name = \"店铺id\", col = 4) private Long storeId; @ExcelAnnotation(name = \"店铺名\", col = 3) private String storeName; @ExcelAnnotation(name = \"开户账号\", col = 5) private String bankAccount; @ExcelAnnotation(name = \"开户用户账号\", col = 6) private String bankUsername; @ExcelAnnotation(name = \"开户行\", col = 7) private String bankName; @ExcelAnnotation(name = \"账单总金额\", col = 8) private BigDecimal orderAmount; @ExcelAnnotation(name = \"应付金额\", col = 9) private BigDecimal handleMoney; @ExcelAnnotation(name = \"实付金额\", col = 10) private BigDecimal paidMoney; @ExcelAnnotation(name = \"账单月\", col = 11) private String billingMonth; @ExcelAnnotation(name = \"账单状态\", col = 12) private Integer status; @ExcelAnnotation(name = \"出账日期\", col = 13, dateFormat = \"yyyy年MM月dd日 HH时mm分ss秒\") private Date issueDateTime; @ExcelAnnotation(name = \"完成时间\", col = 15, dateFormat = \"yyyy年MM月dd日 HH时mm分ss秒\") private Date completeDateTime; @ExcelAnnotation(name = \"开始时间\", col = 14, dateFormat = \"yyyy年MM月dd日 HH时mm分ss秒\") private Date startDateTime; @ExcelAnnotation(name = \"结束时间\", col = 2, dateFormat = \"yyyy年MM月dd日 HH时mm分ss秒\") private Date endDateTime; public ExcelSource(Long billingId, String billingNum, Long storeId, String storeName, String bankAccount, String bankUsername, String bankName, BigDecimal orderAmount, BigDecimal handleMoney, BigDecimal paidMoney, String billingMonth, Integer status, Date issueDateTime, Date completeDateTime, Date startDateTime, Date endDateTime) &#123; super(); this.billingId = billingId; this.billingNum = billingNum; this.storeId = storeId; this.storeName = storeName; this.bankAccount = bankAccount; this.bankUsername = bankUsername; this.bankName = bankName; this.orderAmount = orderAmount; this.handleMoney = handleMoney; this.paidMoney = paidMoney; this.billingMonth = billingMonth; this.status = status; this.issueDateTime = issueDateTime; this.completeDateTime = completeDateTime; this.startDateTime = startDateTime; this.endDateTime = endDateTime; &#125; public Long getBillingId() &#123; return billingId; &#125; public void setBillingId(Long billingId) &#123; this.billingId = billingId; &#125; public String getBillingNum() &#123; return billingNum; &#125; public void setBillingNum(String billingNum) &#123; this.billingNum = billingNum; &#125; public Long getStoreId() &#123; return storeId; &#125; public void setStoreId(Long storeId) &#123; this.storeId = storeId; &#125; public String getStoreName() &#123; return storeName; &#125; public void setStoreName(String storeName) &#123; this.storeName = storeName; &#125; public String getBankAccount() &#123; return bankAccount; &#125; public void setBankAccount(String bankAccount) &#123; this.bankAccount = bankAccount; &#125; public String getBankUsername() &#123; return bankUsername; &#125; public void setBankUsername(String bankUsername) &#123; this.bankUsername = bankUsername; &#125; public String getBankName() &#123; return bankName; &#125; public void setBankName(String bankName) &#123; this.bankName = bankName; &#125; public BigDecimal getOrderAmount() &#123; return orderAmount; &#125; public void setOrderAmount(BigDecimal orderAmount) &#123; this.orderAmount = orderAmount; &#125; public BigDecimal getHandleMoney() &#123; return handleMoney; &#125; public void setHandleMoney(BigDecimal handleMoney) &#123; this.handleMoney = handleMoney; &#125; public BigDecimal getPaidMoney() &#123; return paidMoney; &#125; public void setPaidMoney(BigDecimal paidMoney) &#123; this.paidMoney = paidMoney; &#125; public String getBillingMonth() &#123; return billingMonth; &#125; public void setBillingMonth(String billingMonth) &#123; this.billingMonth = billingMonth; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Date getIssueDateTime() &#123; return issueDateTime; &#125; public void setIssueDateTime(Date issueDateTime) &#123; this.issueDateTime = issueDateTime; &#125; public Date getCompleteDateTime() &#123; return completeDateTime; &#125; public void setCompleteDateTime(Date completeDateTime) &#123; this.completeDateTime = completeDateTime; &#125; public Date getStartDateTime() &#123; return startDateTime; &#125; public void setStartDateTime(Date startDateTime) &#123; this.startDateTime = startDateTime; &#125; public Date getEndDateTime() &#123; return endDateTime; &#125; public void setEndDateTime(Date endDateTime) &#123; this.endDateTime = endDateTime; &#125; &#125; 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package excel;import java.math.BigDecimal;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * @Title: ExcelTest.java * @Package excel * @Description: TODO * @author Zoro * @date 2016年12月30日 下午5:12:52 * @version V1.0 */public class ExcelTest &#123; public static void main(String[] args) &#123; // 数据源 ExcelSource source1 = new ExcelSource(10L, \"1\", 11L, \"01\", \"31\", \"21\", \"41\", new BigDecimal(51), new BigDecimal(61), new BigDecimal(1), \"201601\", 71, new Date(), new Date(), new Date(), new Date()); ExcelSource source2 = new ExcelSource(20L, \"2\", 22L, \"02\", \"32\", \"22\", \"42\", new BigDecimal(52), new BigDecimal(62), new BigDecimal(2), \"202602\", 72, new Date(), new Date(), new Date(), new Date()); ExcelSource source3 = new ExcelSource(30L, \"3\", 33L, \"03\", \"33\", \"23\", \"43\", new BigDecimal(53), new BigDecimal(63), new BigDecimal(3), \"203603\", 73, new Date(), new Date(), new Date(), new Date()); ExcelSource source4 = new ExcelSource(40L, \"4\", 44L, \"04\", \"34\", \"24\", \"44\", new BigDecimal(54), new BigDecimal(64), new BigDecimal(4), \"204604\", 74, new Date(), new Date(), new Date(), new Date()); ExcelSource source5 = new ExcelSource(50L, \"5\", 55L, \"05\", \"35\", \"25\", \"45\", new BigDecimal(55), new BigDecimal(65), new BigDecimal(5), \"205605\", 75, new Date(), new Date(), new Date(), new Date()); ExcelSource source6 = new ExcelSource(60L, \"6\", 66L, \"06\", \"36\", \"26\", \"46\", new BigDecimal(56), new BigDecimal(66), new BigDecimal(6), \"206606\", 76, new Date(), new Date(), new Date(), new Date()); List&lt;ExcelSource&gt; list = new ArrayList&lt;ExcelSource&gt;(); list.add(source1); list.add(source2); list.add(source3); list.add(source4); list.add(source5); list.add(source6); // sheet表设置 SheetArgs&lt;ExcelSource&gt; sheetArgs = new SheetArgs&lt;ExcelSource&gt;(); sheetArgs.sheetName = \"sheet表名\"; sheetArgs.titleName = \"总标题名\"; sheetArgs.clazz = ExcelSource.class; sheetArgs.source = list; // excel文件设置 ExcelArgs excelArgs = new ExcelArgs(); excelArgs.setSheets(sheetArgs); excelArgs.setFileName(\"excel表名\"); try &#123; // 导出 ExcelUtil.exportExcel(excelArgs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 效果图（为了截到完整的数据图，调过列宽）","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"读取jar包中的文件","date":"2016-11-27T03:47:23.000Z","path":"2016/11/27/读取jar包中的文件/","text":"在jar包中读取资源文件，有时，我们的项目需要打成jar包，比如做maven父子依赖的时候，公共的项目被打成jar包放在子项目下，有一些公共的配置也被打入jar包中，读取相应文件的时候，如果按照常规web运行时的方式读取，读取到的路径是xxx.jar!xxx的形式，虽然路径是没有错，但是这种路径并不是一个目录路径，是不可读的，这时就需要用读流的方式来读取了 对于在classpath下的文件，一般web启动时我们都是通过ClassLoader来读取资源文件12345678// 必须和class同级目录或者子目录下才能读到System.out.println(Test.class.getResource(\"\"));// 和调用classloader读取是同一个效果System.out.println(Test.class.getResource(\"/\"));// 效果同上System.out.println(Test.class.getClassLoader().getResource(\"\"));// 这是一种错误的读取方式，使用classloader的时候，不可以指定/来读取System.out.println(Test.class.getClassLoader().getResource(\"/\")); 正确的路径读取如下三种123System.out.println(Test.class.getResource(\"test.txt\")); System.out.println(Test.class.getResource(\"/test.txt\")); System.out.println(Test.class.getClassLoader().getResource(\"test.txt\")); 假设要读取comm项目下的profile/test/test.txt文件，之后comm被打成jar包引入某web项目。通常，我们先获取路径再读取资源1234567891011File f = new File(Test.class.getClassLoader().getResource(&quot;/profile/test/test.txt&quot;).getPath());try(FileInputStream fis = new FileInputStream(f); InputStreamReader read = new InputStreamReader(fis, &quot;UTF-8&quot;); BufferedReader bufferedReader = new BufferedReader(read);) &#123; String line = null; StringBuffer txtcontent = new StringBuffer(); while((lineTxt = bufferedReader.readLine()) != null)&#123; txtcontent.append(line); &#125; System.out.println(txtcontent.toString());&#125; catch (Exception e) &#123; // TODO Exception&#125; 却发现，无论在被打成jar包的类里（comm项目中）读取还是在引用了该jar包的项目中的类（web项目中）读取，都会报找不到路径的错误，改用getResourceAsStream，这时读到的流是可用的1this.getClass().getResourceAsStream(\"/path\"); 代码示例：123456789InputStream is = Test.class.getResourceAsStream(\"/profile/test/test.txt\");InputStreamReader read = new InputStreamReader(is, \"UTF-8\");BufferedReader bufferedReader = new BufferedReader(read);String line = null;StringBuffer txtcontent = new StringBuffer();while ((line = bufferedReader.readLine()) != null) &#123; txtcontent.append(line);&#125;System.out.println(txtcontent.toString());","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java去除Html标签","date":"2016-11-24T09:07:43.000Z","path":"2016/11/24/Java去除Html标签/","text":"普通的正则去除标签1234// 剔出&lt;html&gt;的标签String txtcontent = htmlcontent.replaceAll(\"&lt;/?[^&gt;]+&gt;\", \"\");// 去除字符串中的空格,回车,换行符,制表符txtcontent = txtcontent.replaceAll(\"&lt;a&gt;\\\\s*|\\t|\\r|\\n&lt;/a&gt;\", \"\"); 但是有时候html标签比较复杂，容易忽略掉很多，这时就可以使用Jsoup工具来完成这种复杂的解析，如果使用了maven，引入jar包12345 &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt; 工具类代码如下：1234567891011121314151617181920212223242526import org.jsoup.Jsoup;import org.jsoup.nodes.Document;public class HtmlUtil &#123; /** * @Title: getText * @Description: 解析html标签 * @param @param html串 * @return 文本内容 */ public static String getText(String html) &#123; Document doc = Jsoup.parse(html); String txtcontent = doc.text(); StringBuilder builder = new StringBuilder(txtcontent); int index = 0; while (builder.length() &gt; index) &#123; char tmp = builder.charAt(index); if (Character.isSpaceChar(tmp) || Character.isWhitespace(tmp)) &#123; builder.setCharAt(index, ' '); &#125; index++; &#125; txtcontent = builder.toString().replaceAll(\" +\", \" \").trim(); return txtcontent; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"spring4.0读取properties文件","date":"2016-09-24T09:02:22.000Z","path":"2016/09/24/获取properties文件键值/","text":"若我们的项目配置了多环境注入properties属性，spring4.0配置，要引入xmlns:util=”http://www.springframework.org/schema/util&quot;和http://www.springframework.org/schema/util/spring-util-4.0.xsd我的配置是1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd \"&gt; &lt;description&gt;spring总配置&lt;/description&gt; &lt;!-- 打开Spring的Annotation支持 --&gt; &lt;context:annotation-config /&gt; &lt;!-- 设定Spring 去哪些包中找Annotation --&gt; &lt;context:component-scan base-package=\"com.test\" /&gt; &lt;!-- 使用aop --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\" /&gt; &lt;!-- 读入配置属性文件 --&gt; &lt;context:property-placeholder location=\"classpath:$&#123;profiles.active&#125;/system.properties\" /&gt; &lt;util:properties id=\"pro\" location=\"classpath:$&#123;profiles.active&#125;/system.properties\"/&gt; &lt;!--引入其他spring配置文件 --&gt; &lt;import resource=\"classpath:spring/spring-datasource.xml\" /&gt; &lt;import resource=\"classpath:spring/spring-mybatits.xml\" /&gt; &lt;import resource=\"classpath:spring/spring-transaction.xml\" /&gt; &lt;import resource=\"classpath:spring/spring-redis.xml\" /&gt;&lt;/beans&gt; 在类中的属性上@Value(“#{pro.xxx}”)就可以自动注入了12345678910111213141516171819202122232425262728293031package com.sq580.mall.common.util.proper;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class PropsUtils &#123; @Value(\"#&#123;pro.protocal&#125;\") private String protocal; @Value(\"#&#123;pro.endpoint&#125;\") private String endpoint; public String getProtocal() &#123; return protocal; &#125; public void setProtocal(String protocal) &#123; this.protocal = protocal; &#125; public String getEndpoint() &#123; return endpoint; &#125; public void setEndpoint(String endpoint) &#123; this.endpoint = endpoint; &#125; &#125; 直接在需要使用的地方注入PropsUtils，然后get需要的属性即可，需要注意的是，配置中的属性名不能使用“.”","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java自定义验证注解","date":"2016-08-21T08:21:16.000Z","path":"2016/08/21/Java自定义验证注解/","text":"元注解：Java5定义了4个标准的meta-annotation类型 1、@Target：表示Annotation所修饰的对象范围 取值(ElementType)有： 1）CONSTRUCTOR:用于描述构造器 2）FIELD:用于描述域 3）LOCAL_VARIABLE:用于描述局部变量 4）METHOD:用于描述方法 5）PACKAGE:用于描述包 6）PARAMETER:用于描述参数 7）TYPE:用于描述类、接口(包括注解类型) 或enum声明 2、@Retention：表示Annotation被保留的时间长短 取值(RetentionPoicy)有： 1）SOURCE:在源文件中有效（即源文件保留） 2）CLASS:在class文件中有效（即class保留） 3）RUNTIME:在运行时有效（即运行时保留） 3、@Documented：用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员 4、@Inherited：阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类 hibernate的@Valid注解为我们提供了很多的验证方式，但是并不能完全满足我们的需求如下的一个bean，需要联合起来判断，上下午不能同时为空，当开始/结束时间不为空时，结束/开始时间也不能为空12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.sq580.mall.goods.web.vo;/** * @Title: DayTime.java * @Package com.sq580.mall.goods.web.vo * @company： 社区580 * @Description: TODO * @author zfs * @date 2016年11月5日 下午2:05:52 * @version V1.0 */@DateTimeNotNullpublic class DayTime &#123; private String morningStartDateTime; private String morningEndDateTime; private String afternoonStartDateTime; private String afternoonEndDateTime; public String getMorningStartDateTime() &#123; return morningStartDateTime; &#125; public void setMorningStartDateTime(String morningStartDateTime) &#123; this.morningStartDateTime = morningStartDateTime; &#125; public String getMorningEndDateTime() &#123; return morningEndDateTime; &#125; public void setMorningEndDateTime(String morningEndDateTime) &#123; this.morningEndDateTime = morningEndDateTime; &#125; public Integer getMorningNum() &#123; return morningNum; &#125; public void setMorningNum(Integer morningNum) &#123; this.morningNum = morningNum; &#125; public String getAfternoonStartDateTime() &#123; return afternoonStartDateTime; &#125; public void setAfternoonStartDateTime(String afternoonStartDateTime) &#123; this.afternoonStartDateTime = afternoonStartDateTime; &#125; public String getAfternoonEndDateTime() &#123; return afternoonEndDateTime; &#125; public void setAfternoonEndDateTime(String afternoonEndDateTime) &#123; this.afternoonEndDateTime = afternoonEndDateTime; &#125; public Integer getAfternoonNum() &#123; return afternoonNum; &#125; public void setAfternoonNum(Integer afternoonNum) &#123; this.afternoonNum = afternoonNum; &#125; @Override public String toString() &#123; return \"DayTime [morningStartDateTime=\" + morningStartDateTime + \", morningEndDateTime=\" + morningEndDateTime + \", morningNum=\" + morningNum + \", afternoonStartDateTime=\" + afternoonStartDateTime + \", afternoonEndDateTime=\" + afternoonEndDateTime + \", afternoonNum=\" + afternoonNum + \"]\"; &#125;&#125; 定义一个验证接口（标准格式）123456789101112131415161718192021222324252627package test;import java.lang.annotation.Documented;import java.lang.annotation.Retention;import java.lang.annotation.Target;import javax.validation.Constraint;import javax.validation.Payload;import test.DayTimeValid;@Constraint(validatedBy = DayTimeValid.class)@Target( &#123; java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.TYPE&#125; )@Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @Documentedpublic @interface DateTimeNotNull &#123; String message() default \"&#123;时间不能为空！&#125;\"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; &#125; 验证类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package test;import java.text.ParseException;import java.text.SimpleDateFormat;import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;import test.DayTime;import test.DateTimeNotNull;public class DayTimeValid implements ConstraintValidator&lt;DateTimeNotNull, DayTime&gt; &#123; private final static SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm\"); @Override public void initialize(DayTimeVo obj) &#123; &#125; @Override public boolean isValid(DayTime daytime, ConstraintValidatorContext constraintValidatorContext) &#123; constraintValidatorContext.disableDefaultConstraintViolation(); if (daytime.getMorningStartDateTime() == null &amp;&amp; daytime.getMorningEndDateTime() == null &amp;&amp; daytime.getAfternoonStartDateTime() == null &amp;&amp; daytime.getAfternoonEndDateTime() == null) &#123; constraintValidatorContext.buildConstraintViolationWithTemplate( \"服务时间不能为空！\").addConstraintViolation(); return false; &#125; else if (daytime.getMorningStartDateTime() == null &amp;&amp; daytime.getMorningEndDateTime() != null) &#123; constraintValidatorContext.buildConstraintViolationWithTemplate( \"上午开始时间不能为空！\").addConstraintViolation(); return false; &#125; else if (daytime.getMorningStartDateTime() != null &amp;&amp; daytime.getMorningEndDateTime() == null) &#123; constraintValidatorContext.buildConstraintViolationWithTemplate( \"上午结束时间不能为空！\").addConstraintViolation(); return false; &#125; else if (daytime.getAfternoonStartDateTime() == null &amp;&amp; daytime.getAfternoonEndDateTime() != null) &#123; constraintValidatorContext.buildConstraintViolationWithTemplate( \"下午开始时间不能为空！\").addConstraintViolation(); return false; &#125; else if (daytime.getAfternoonStartDateTime() != null &amp;&amp; daytime.getAfternoonEndDateTime() == null) &#123; constraintValidatorContext.buildConstraintViolationWithTemplate( \"下午结束时间不能为空！\").addConstraintViolation(); return false; &#125; else if (daytime.getMorningStartDateTime() != null &amp;&amp; daytime.getMorningEndDateTime() != null) &#123; try &#123; sdf.parse(daytime.getMorningStartDateTime()); &#125; catch (ParseException e) &#123; constraintValidatorContext .buildConstraintViolationWithTemplate(\"上午开始时间格式不正确！\") .addConstraintViolation(); return false; &#125; try &#123; sdf.parse(daytime.getMorningEndDateTime()); &#125; catch (ParseException e) &#123; constraintValidatorContext .buildConstraintViolationWithTemplate(\"上午结束时间格式不正确！\") .addConstraintViolation(); return false; &#125; &#125; else if (daytime.getAfternoonStartDateTime() != null &amp;&amp; daytime.getAfternoonEndDateTime() != null) &#123; try &#123; sdf.parse(daytime.getAfternoonStartDateTime()); &#125; catch (ParseException e) &#123; constraintValidatorContext .buildConstraintViolationWithTemplate(\"下午开始时间格式不正确！\") .addConstraintViolation(); return false; &#125; try &#123; sdf.parse(daytime.getAfternoonEndDateTime()); &#125; catch (ParseException e) &#123; constraintValidatorContext .buildConstraintViolationWithTemplate(\"下午结束时间格式不正确！\") .addConstraintViolation(); return false; &#125; &#125; return true; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Mybatis执行insert后获取主键方式","date":"2016-08-21T08:21:16.000Z","path":"2016/08/21/Mybatis执行insert后获取主键方式/","text":"123在hibernate中，hibernate的一级缓存会把insert后的主键绑定到对象中，我们可以直接在session.save(user);后直接使用user.getId();的方式来取得插入后的主键，而在mybatis中，我们一般使用mapper.xml来编辑sql语句，当我们执行insert后，返回的model中并没有帮我们把主键返回 使用selectKey来实现类似JDBC的getGeneratedKeys();获取主键的功能1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"test.dao.UserDao\" &gt; &lt;resultMap id=\"BaseResultMap\" type=\"test.model.User\" &gt; &lt;id column=\"store_id\" property=\"storeId\" jdbcType=\"BIGINT\" /&gt; &lt;result column=\"name\" property=\"name\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"role\" property=\"role\" jdbcType=\"BIGINT\" /&gt; &lt;result column=\"mobile\" property=\"mobile\" jdbcType=\"VARCHAR\" /&gt; &lt;/resultMap&gt; &lt;insert id=\"insert\" parameterType=\"test.model.User\"&gt; insert into u_user &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\" &gt; &lt;if test=\"userId != null\" &gt; user_id, &lt;/if&gt; &lt;if test=\"name != null\" &gt; name, &lt;/if&gt; &lt;if test=\"role != null\" &gt; role, &lt;/if&gt; &lt;if test=\"mobile != null\" &gt; mobile, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\" &gt; &lt;if test=\"userId != null\" &gt; #&#123;userId,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test=\"name != null\" &gt; #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"role != null\" &gt; #&#123;role,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test=\"mobile != null\" &gt; #&#123;mobile,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;selectKey resultType=\"java.lang.Long\" keyProperty=\"userId\"&gt; &lt;![CDATA[SELECT LAST_INSERT_ID() AS user_id ]]&gt; &lt;/selectKey&gt;&lt;/insert&gt; 这里需要说明一下不同的数据库主键的生成，对各自的数据库有不同的方式：123mysql: SELECT LAST_INSERT_ID() AS VALUEmssql: SELECT @@IDENTITY AS VALUEoracle: SELECT STOCKIDSEQUENCE.NEXTVAL AS VALUE FROM DUAL 还有一点需要注意的是不同的数据库生产商生成主键的方式不一样，有些是预先生成 (pre-generate)主键的，如Oracle和PostgreSQL。有些是事后生成(post-generate)主键的，如MySQL和SQL Server 所以如果是Oracle数据库，则需要将selectKey写在insert语句之前","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"eclipse安装svn","date":"2016-08-21T04:59:58.000Z","path":"2016/08/21/eclipse安装svn/","text":"在线安装： 打开Eclipse Help-&gt;Software Updates-&gt;find and install(如果没有这个就用help-&gt;Software Updates-&gt;Add/Remove Software即可) 选择search for new features to install, Next 点击new remote site（有以下版本可供选择） 输入 Name: Subclipse 1.6.x (Eclipse 3.2+) URL: http://subclipse.tigris.org/update_1.6.x 或 Name: Subclipse 1.4.x (Eclipse 3.2+) URL:http://subclipse.tigris.org/update_1.4.x 或 Name: Subclipse 1.2.x (Eclipse 3.2+) URL: http://subclipse.tigris.org/update_1.2.x 或 Name: Subclipse 1.0.x (Eclipse 3.0/3.1) 选中subclipse，点击finish，一路NEXT。 注意：有些时候会出现 Subclipse Integration for Mylyn 3.x (Optional) (3.0.0) requires plug-in “org.eclipse.mylyn.tasks.core (3.0.0)”, or compatible.错误，这个不要紧，在弹出框中选择subclipse，把Subclipse Integration for Mylyn 3.x选项去掉即可Next一路安装完成！","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]},{"title":"Controller异常处理","date":"2016-08-07T02:29:33.000Z","path":"2016/08/07/Controller异常处理/","text":"12345一般来说，项目中的错误最好手动处理，避免尴尬直接抛错给请求者，但是在一些特殊情况中，比如我们在用SpringMvc的@RequestBody注入对象的时候可能很方便，但是在联调阶段也会出现很多尴尬的问题，比如我们定义了一个注入的model中的price是一个decimal类型，那么按理说需要前端提供一个类似0.00的值上来，但是像网页端，若是用input标签来实现且price非必填，一般就直接传了个&quot;&quot;上来，这是注入的时候就会出现类型转换失败的情况。 下面回到正题，使用@ExceptionHandler，当Controller中任何一个方法发生异常，定义一个默认的方法拦截，一般来说最好定义在父类中，然后所有Controller都继承该类代码示例：123456789101112131415161718192021222324252627282930313233343536import com.alibaba.fastjson.JSONException;@Controllerpublic class AccessController &#123; /** * 异常控制 * @Title: handleOtherExceptions * @Description: RequestBody用fastjson解析出错的统一处理 * @param @param ex * @param @return * @return ResponseEntity&lt;Object&gt; * @throws */ @ExceptionHandler(JSONException.class) public ResponseEntity&lt;Object&gt; handleOtherExceptions(JSONException e) &#123; Result result = new Result(); String eMsg = e.getMessage(); if (eMsg.contains(\"not match : - \")) &#123; result.setFailResultMsg(\"json数据格式不正确，没有匹配的 '&#125;' 或 '\\\"'\"); &#125; else if (eMsg.contains(\"unclosed string\")) &#123; result.setFailResultMsg(\"json数据格式不正确，没有闭合的 '\\\"'\"); &#125; else if(eMsg.contains(\"syntax error, \")) &#123; result.setFailResultMsg(\"json数据格式不正确： \"); &#125; else if (eMsg.contains(\"can not cast to\")) &#123; String[] msg = eMsg.split(\" \"); result.setFailResultMsg(\"转换类型失败：值 '\" + msg[7] + \"' 不能转成 \" + msg[4].replace(\",\", \"\") + \" 类型\"); &#125; else &#123; result.setFailResultMsg(\"未知异常： \" + eMsg); &#125; return new ResponseEntity&lt;Object&gt;(result, HttpStatus.OK); &#125;&#125; 还有一种方式，使用 @ControllerAdvice只要把这个类放在项目中，Spring能扫描到的地方，就可以实现全局异常的回调。代码示例：1234567891011121314151617@ControllerAdvicepublic class SpringExceptionHandler &#123; /** * 全局处理Exception * 错误的情况下返回500 * @param e * @param req * @return */ @ExceptionHandler(value = &#123;Exception.class&#125;) public ResponseEntity&lt;Object&gt; handleOtherExceptions(final Exception e, final WebRequest req) &#123; TResult tResult = new TResult(); tResult.setStatus(CodeType.V_500); tResult.setErrorMessage(ex.getMessage()); return new ResponseEntity&lt;Object&gt;(tResult,HttpStatus.OK); &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"使用fatjar打包项目","date":"2016-07-28T03:29:07.000Z","path":"2016/07/28/fatjar打包项目/","text":"123直接用eclipse打包项目，如果项目有依赖的jar包，则运行时需要将生成的jar文件和存放引用包的lib文件夹放在同一个目录下，但是这种方式十分不美观，在非maven项目中，推荐使用fatjar打包项目，fatjar工具可以把引用包也引入到生成的jar文件中，使用方法不做解释，下面为使用失败的记录。 因为fatjar只有0.0.31版本，而0.0.31版本在eclipse 3.4之后就再没有更新过了，导致新版本的eclipse无法使用，有以下几种解决方案一、下载eclipse兼容版本插件 使用eclipse的Help&gt;Install new software&gt;Work with后面的Add按钮，分别填入 The Eclipse Project Updates 和 http://download.eclipse.org/eclipse/updates/x.x（x.x是你目前eclipse的版本，我是4.4） 选中Eclipse Tests,Examples,and Extras下的Eclipse 2.0 Style Plugin Support，安装，安装完会提示重启，重启。 这个时候eclipse就兼容了2.0插件，这时可使用以下两种方式安装fatjar插件: 1.直接下载 fat-jar它是sourceforge.net下的一个开源工具，从 http://sourceforge.net/projects/fjep/files/地址可以下载该工具，下载完成后是一个zip压缩包，将包中的net.sf.fjep.fatjar_0.0.31.jar放到eclipse安装目录的plugins下，重启eclipse即可（虽简单粗暴，但不推荐） 如果下载不了，可以到我的csdn下载：下载地址 2.在线安装 Help&gt;Install new software&gt;Add-Name:Fat Jar;Location:http://kurucz-grafika.de/fatjar&gt;OK&gt;一直next，不管安装什么，Contact all update sites during install to find required softaware一般都不勾选，不然等更新要等很久 二、下载更高版本的fastjar工具–net.sf.fjep.fatjar_0.0.32.jar(大神改过的)放到eclipse安装目录的plugins下，重启eclipse即可 附fatjar0.0.32: 下载地址 实在不行的话，就把第一种方法中的fatjar版本改成小一点的试试，如果还不行，就用maven打包吧","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]},{"title":"open implementation异常退出","date":"2016-07-17T06:27:48.000Z","path":"2016/07/17/open implementation异常退出/","text":"eclipse使用Ctrl+鼠标点击open implementation和open super implementation时会出现eclipse异常退出的现象，后来发现是谷歌输入法导致的冲突，卸载换个输入法就好了","tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]},{"title":"SpringMvc接收参数","date":"2016-07-17T06:27:48.000Z","path":"2016/07/17/SpringMvc接收参数/","text":"SpringMvc接收对象的方式1、最普通的我们可以用HttpServletRequest对象来接收，但下面的方式我们只能用来接收键值对，对application/json之类的类型就没有用了，需要读取request的流再解析出参数request.getParameter(name); 2、但既然用了SpringMvc我们可以用注解的方式来获取各种参数1）@PathVariable 当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。示例代码：123456789@Controller@RequestMapping(\"/user/&#123;operation&#125;\")public class UserController &#123; @RequestMapping(\"/&#123;userId&#125;\") public void findPet(@PathVariable String operation, @PathVariable String userId, Model model) &#123; // TODO &#125;&#125; 2）@RequestHeader @RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上。常见的header：123456Accept: image/webp,image/*,*/*;q=0.8Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.8Host: localhost:8080Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 示例代码：1234567891011@Controller@RequestMapping(\"/user\")public class UserController &#123; @RequestMapping(\"/getlist\") public void findPet( @RequestHeader(\"Accept-Encoding\") String encoding, @RequestHeader(\"Keep-Alive\") long keepAlive) &#123; // TODO &#125;&#125; 3）@CookieValue @CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。例如有如下Cookie值：1JSESSIONID=070c17a0028d1dcc66eba40e7781d177 示例代码：123456789@Controller@RequestMapping(\"/user\")public class UserController &#123; @RequestMapping(\"/login\") public void findPet(@CookieValue(\"JSESSIONID\") String cookie) &#123; // TODO &#125;&#125; 4）@RequestParam@RequestParam等同于request.getParameter();@RequestParam用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式为GET、POST；@RequestParam有两个属性： value：用来指定要传入值的name required：用来指定参数是否必须示例代码：123456789@Controller@RequestMapping(\"/user\")public class UserController &#123; @RequestMapping(\"/login\", method = RequestMethod.GET) public void findPet(@RequestParam(\"userId\") String userId) &#123; // TODO &#125;&#125; 5）@RequestBody像ajax原生的请求就是application/json类型，此时用@RequestBody就十分合适@RequestBody常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；但是注意springmvc4.2版本才能直接转对象，4.2之前只能接收String示例代码：12345678910111213141516@Controller@RequestMapping(\"/user\")public class UserController &#123; // 4.2之前接收String @RequestMapping(\"/login\", method = RequestMethod.POST) public void findPet(@RequestBody String body) &#123; User user = (User) JSON.parse(body); &#125; // 4.2之后接收bean @RequestMapping(\"/login\", method = RequestMethod.POST) public void findPet(@RequestBody User user) &#123; return user.getName(); &#125; &#125; 6）@SessionAttributes@SessionAttribute用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。示例代码：12345678910@Controller @RequestMapping(\"/user\")@SessionAttributes(\"userId\")public class UserController &#123; @RequestMapping(\"/login\", method = RequestMethod.POST) public void findPet() &#123; // TODO &#125;&#125; 7）@ModelAttribute@ModelAttribute可以用在方法上也可以用在参数上，@ModelAttribute只能获取键值对，即接收的Content-Type是from-data或者application/x-www-form等类型首先是用在方法上时，相当于为request对象的model里put(“account”, Account);如此在使用@RequestParam时就不需要带上参数名了示例代码：12345678910@Controller @RequestMapping(\"/user\")public class UserController &#123; @RequestMapping(\"/login\", method = RequestMethod.POST) @ModelAttribute public void findPet(@RequestParam String userId) &#123; return accountManager.findAccount(userId); &#125;&#125; 如果是在参数上时，一般来说，我们需要的是request中的参数，所以这里说明一下，@ModelAttribute绑定参数的来源 A） 首先是 @SessionAttributes 上绑定的attribute 对象 B） 没有就查询@ModelAttribute 用于方法上时指定的model对象 C） 当两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。示例代码：123456789@Controller @RequestMapping(\"/user\")public class UserController &#123; @RequestMapping(\"/login\", method = RequestMethod.POST) public void findPet(@ModelAttribute User user) &#123; // TODO &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"http://yoursite.com/tags/SpringMvc/"}]},{"title":"Java操作redis","date":"2016-07-17T03:53:17.000Z","path":"2016/07/17/Java操作redis/","text":"Jedis的简单使用1234567891011121314151617181920212223242526272829303132package test;import java.util.Iterator;import java.util.List;import java.util.Set;import redis.clients.jedis.Jedis;public class Test &#123; public static void main(String[] args) &#123; // 连接本地的 redis 服务 Jedis jedis = new Jedis(\"localhost\"); System.out.println(\"Connection to server sucessfully\"); // 存储数据到列表中 jedis.lpush(\"tutorial-list\", \"Redis\"); jedis.lpush(\"tutorial-list\", \"Mongodb\"); jedis.lpush(\"tutorial-list\", \"Mysql\"); // 获取存储的数据并输出 List&lt;String&gt; list = jedis.lrange(\"tutorial-list\", 0, 5); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(\"Stored string in redis: \" + list.get(i)); &#125; // 获取数据并输出 Set&lt;String&gt; list1 = jedis.keys(\"*\"); Iterator&lt;String&gt; it = list1.iterator(); while (it.hasNext()) &#123; System.out.println(\"List of stored keys: \" + it.next()); &#125; &#125; &#125; 在实际的开发中操作redis总是需要用到连接池，同时redis也需要加密先说一下windows上加密的坑123456789101112设置密码：redis 127.0.0.1:6379&gt; config set requirepass test123查询密码：redis 127.0.0.1:6379&gt; config get requirepass(error) ERR operation not permitted密码验证：redis 127.0.0.1:6379&gt; auth test123OK再次查询：redis 127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;test123&quot; PS：如果配置文件中没添加密码 那么redis重启后，密码失效；所以我们需要在配置文件中配置requirepass的密码（当redis重启时密码依然有效）。打开redis.windows.conf配置文件，找到requirepass，然后修改如下:1requirepass yourpassword 然而发现在windows下，启动redis-server.exe后用redis-cli.exe登录后并不需要密码验证，原因是redis-server.exe的启动并不依赖redis.windows.conf，我的解决方法是为redis-server.exe创建一个快捷方式，然后右键属性，将目标后加上：（空格）+ redis.windows.conf，如果有更好的方法，欢迎留言。 当然，如果想把redis注册成windows服务也可以12345678注册服务Redis-server.exe –service-install redis.windows.conf删除服务redis-server –service-uninstall开启服务redis-server –service-start停止服务redis-server –service-stop 下面提供jedis操作的工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807package test.util;import java.util.List;import java.util.Map;import java.util.Set;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.google.common.collect.Maps;import test.util.ObjectUtils;import test.util.StringUtil;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.exceptions.JedisException;public class JedisUtils &#123; private final static Logger logger = LoggerFactory.getLogger(JedisUtils.class); public final static int DEFAULT_CACHE_SECONDS = 30 * 60; //缓存30分钟 // 这里如果用spring的话可以使用配置注入，配置见文章末尾 public JedisPool jedisPool; public JedisPool getJedisPool() &#123; return jedisPool; &#125; public void setJedisPool(JedisPool jedisPool) &#123; this.jedisPool = jedisPool; &#125; // 如果不使用注入，这里初始化一下连接池 public void init() &#123; if (jedisPool== null) &#123; JedisPoolConfig config = new JedisPoolConfig(); // 控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取 config.setMaxActive(50); // 控制一个pool最多有多少个状态为idle(空闲的)的jedis实例 config.setMaxIdle(5); // 表示当borrow(引入)一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛出JedisConnectionException config.setMaxWait(1000 * 100); // 在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的 config.setTestOnBorrow(true); // 这里获取配置不多说，后面的3600表示超时时间，database表示数据库号，都可以不填 pool = new JedisPool(config, \"host:port\", password, 3600, database); &#125; &#125; /** * 获取缓存 * @param key 键 * @return 值 */ public String get(String key)throws Exception &#123; String value = null; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; value = jedis.get(key); value = StringUtils.isNotBlank(value) &amp;&amp; !\"nil\".equalsIgnoreCase(value) ? value : null; logger.debug(\"get &#123;&#125; = &#123;&#125;\", key, value); &#125; &#125; catch (Exception e) &#123; logger.warn(\"get &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return value; &#125; /** * 获取缓存 * @param key 键 * @param cacheSeconds 缓存时间 * @return 值 */ public String get(String key, int cacheSeconds)throws Exception &#123; String value = null; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; value = jedis.get(key); if (cacheSeconds != 0) &#123; jedis.expire(key, cacheSeconds); &#125; value = StringUtils.isNotBlank(value) &amp;&amp; !\"nil\".equalsIgnoreCase(value) ? value : null; logger.debug(\"get &#123;&#125; = &#123;&#125;\", key, value); &#125; &#125; catch (Exception e) &#123; logger.warn(\"get &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return value; &#125; /** * 设置缓存 * @param key 键 * @param value 值 * @param cacheSeconds 超时时间，0为不超时 * @return */ public String set(String key, String value, int cacheSeconds) throws Exception&#123; String result = null; Jedis jedis = null; try &#123; jedis = getResource(); result = jedis.set(key, value); if (cacheSeconds != 0) &#123; jedis.expire(key, cacheSeconds); &#125; logger.debug(\"set &#123;&#125; = &#123;&#125;\", key, value); &#125; catch (Exception e) &#123; logger.warn(\"set &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 获取单个hash缓存 * @param @param key * @param @param field * @return String */ public String hget(String key, String field) throws Exception &#123; String value = null; Jedis jedis = null; try &#123; jedis = getResource(); value = jedis.hget(key, field); value = StringUtils.isNotBlank(value) &amp;&amp; !\"nil\".equalsIgnoreCase(value) ? value : null; logger.debug(\"hget &#123;&#125; = &#123;&#125;\", field, value); &#125; catch (Exception e) &#123; logger.warn(\"hget &#123;&#125; = &#123;&#125;\", field, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return value; &#125; /** * 设置单个hash缓存 * @param @param key * @param @param field * @return String */ public String hset(String key, String field, String value) throws Exception &#123; String result = null; Jedis jedis = null; try &#123; jedis = getResource(); jedis.hset(key, field, value); logger.debug(\"hset &#123;&#125; : &#123;&#125; = &#123;&#125;\", key, field, value); &#125; catch (Exception e) &#123; logger.warn(\"hset &#123;&#125; : &#123;&#125; = &#123;&#125;\", key, field, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 获取List缓存 * @param key 键 * @return 值 */ public List&lt;String&gt; getList(String key) throws Exception&#123; List&lt;String&gt; value = null; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; value = jedis.lrange(key, 0, -1); logger.debug(\"getList &#123;&#125; = &#123;&#125;\", key, value); &#125; &#125; catch (Exception e) &#123; logger.warn(\"getList &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return value; &#125; /** * 设置List缓存 * @param key 键 * @param value 值 * @param cacheSeconds 超时时间，0为不超时 * @return */ public long setList(String key, List&lt;String&gt; value, int cacheSeconds)throws Exception &#123; long result = 0; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; jedis.del(key); &#125; result = jedis.rpush(key, (String[])value.toArray()); if (cacheSeconds != 0) &#123; jedis.expire(key, cacheSeconds); &#125; logger.debug(\"setList &#123;&#125; = &#123;&#125;\", key, value); &#125; catch (Exception e) &#123; logger.warn(\"setList &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 向List缓存中添加值 * @param key 键 * @param value 值 * @return */ public long listAdd(String key, String... value)throws Exception &#123; long result = 0; Jedis jedis = null; try &#123; jedis = getResource(); result = jedis.rpush(key, value); logger.debug(\"listAdd &#123;&#125; = &#123;&#125;\", key, value); &#125; catch (Exception e) &#123; logger.warn(\"listAdd &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 获取有序zet缓存 （按分值由低到高排序输出） * @param key 键 * @return 值 */ public Set&lt;String&gt; getZsetZrange(String key) throws Exception &#123; return getZsetZrange(key,0 , -1); &#125; /** * 获取有序zet缓存 （按分值由高到低排序输出） * @param key 键 * @return 值 */ public Set&lt;String&gt; getZsetZrevrange(String key)throws Exception&#123; return getZsetZrevrange(key,0 , -1); &#125; /** * * @Title: getZsetZrangePage * @Description: 分页获取 获取有序zet缓存 （按分值由低到高排序输出） * @param @param key * @param @param end * @param @return * @return Set&lt;String&gt; * @throws */ public Set&lt;String&gt; getZsetZrange(String key,long start , long end) throws Exception&#123; Set&lt;String&gt; value = null; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; value = jedis.zrange(key, start, end); logger.debug(\"getZset &#123;&#125; = &#123;&#125;\", key, value); &#125; &#125; catch (Exception e) &#123; logger.warn(\"getZset &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return value; &#125; /** * * @Title: getZsetZrevrange * @Description: 获取有序zet缓存 （按分值由高到低排序输出） * @param @param key * @param @param start * @param @param end * @param @return * @return Set&lt;String&gt; * @throws */ public Set&lt;String&gt; getZsetZrevrange(String key,long start , long end) throws Exception&#123; Set&lt;String&gt; value = null; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; value = jedis.zrevrange (key, start,end); logger.debug(\"getZset &#123;&#125; = &#123;&#125;\", key, value); &#125; &#125; catch (Exception e) &#123; logger.warn(\"getZset &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return value; &#125; /** * 设置Set缓存 * @param key 键 * @param value 值 * @param cacheSeconds 超时时间，0为不超时 * @return */ public long setZset(String key, Map&lt;String, Double&gt; scoreMembers, int cacheSeconds) throws Exception&#123; long result = 0; Jedis jedis = null; boolean isExists = false; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; isExists = true; &#125; jedis.zadd(key, scoreMembers); if (!isExists &amp;&amp; cacheSeconds != 0) &#123; jedis.expire(key, cacheSeconds); &#125; logger.debug(\"setZset &#123;&#125; = &#123;&#125;\", key, scoreMembers); &#125; catch (Exception e) &#123; logger.warn(\"setZset &#123;&#125; = &#123;&#125;\", key, scoreMembers, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 获取Map缓存 * @param key 键 * @return 值 */ public Map&lt;String, String&gt; getMap(String key) throws Exception&#123; Map&lt;String, String&gt; value = null; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; value = jedis.hgetAll(key); logger.debug(\"getMap &#123;&#125; = &#123;&#125;\", key, value); &#125; &#125; catch (Exception e) &#123; logger.warn(\"getMap &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return value; &#125; /** * 获取Map缓存里某个key的值 * @Title: getMapKeyVal * @Description: TODO * @param @param key * @param @param mapKey * @param @return * @return String * @throws */ public String getMapKeyVal(String key,String mapKey) throws Exception&#123; String value = null; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; if(jedis.hexists(key, mapKey))&#123; value = jedis.hget(key, mapKey); logger.debug(\"getMap &#123;&#125; &#123;&#125; = &#123;&#125;\", key, mapKey,value); &#125; &#125; &#125; catch (Exception e) &#123; logger.warn(\"getMap &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return value; &#125; /** * 获取Map缓存 * @param key 键 * @return 值 */ public Map&lt;String, Object&gt; getObjectMap(String key) throws Exception&#123; Map&lt;String, Object&gt; value = null; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(getBytesKey(key))) &#123; value = Maps.newHashMap(); Map&lt;byte[], byte[]&gt; map = jedis.hgetAll(getBytesKey(key)); for (Map.Entry&lt;byte[], byte[]&gt; e : map.entrySet())&#123; value.put(StringUtil.toString(e.getKey()), toObject(e.getValue())); &#125; logger.debug(\"getObjectMap &#123;&#125; = &#123;&#125;\", key, value); &#125; &#125; catch (Exception e) &#123; logger.warn(\"getObjectMap &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return value; &#125; /** * 设置Map缓存 * @param key 键 * @param value 值 * @param cacheSeconds 超时时间，0为不超时 * @return */ public String setMap(String key, Map&lt;String, String&gt; value, int cacheSeconds)throws Exception &#123; String result = null; Jedis jedis = null; boolean isExists = false; try &#123; jedis = getResource(); if (jedis.exists(key)) &#123; isExists = true; &#125; result = jedis.hmset(key, value); if (!isExists &amp;&amp; cacheSeconds != 0) &#123; jedis.expire(key, cacheSeconds); &#125; logger.debug(\"setMap &#123;&#125; = &#123;&#125;\", key, value); &#125; catch (Exception e) &#123; logger.warn(\"setMap &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 设置Map缓存 * @param key 键 * @param value 值 * @param cacheSeconds 超时时间，0为不超时 * @return */ public String setObjectMap(String key, Map&lt;String, Object&gt; value, int cacheSeconds) throws Exception&#123; String result = null; Jedis jedis = null; boolean isExists = false; try &#123; jedis = getResource(); if (jedis.exists(getBytesKey(key))) &#123; isExists = true; &#125; Map&lt;byte[], byte[]&gt; map = Maps.newHashMap(); for (Map.Entry&lt;String, Object&gt; e : value.entrySet())&#123; map.put(getBytesKey(e.getKey()), toBytes(e.getValue())); &#125; result = jedis.hmset(getBytesKey(key), (Map&lt;byte[], byte[]&gt;)map); if (!isExists &amp;&amp; cacheSeconds != 0) &#123; jedis.expire(key, cacheSeconds); &#125; logger.debug(\"setObjectMap &#123;&#125; = &#123;&#125;\", key, value); &#125; catch (Exception e) &#123; logger.warn(\"setObjectMap &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 向Map缓存中添加值 * @param key 键 * @param value 值 * @return */ public String mapPut(String key, Map&lt;String, String&gt; value) throws Exception&#123; String result = null; Jedis jedis = null; try &#123; jedis = getResource(); result = jedis.hmset(key, value); logger.debug(\"mapPut &#123;&#125; = &#123;&#125;\", key, value); &#125; catch (Exception e) &#123; logger.warn(\"mapPut &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 向Map缓存中添加值 * @param key 键 * @param value 值 * @return */ public String mapObjectPut(String key, Map&lt;String, Object&gt; value)throws Exception &#123; String result = null; Jedis jedis = null; try &#123; jedis = getResource(); Map&lt;byte[], byte[]&gt; map = Maps.newHashMap(); for (Map.Entry&lt;String, Object&gt; e : value.entrySet())&#123; map.put(getBytesKey(e.getKey()), toBytes(e.getValue())); &#125; result = jedis.hmset(getBytesKey(key), (Map&lt;byte[], byte[]&gt;)map); logger.debug(\"mapObjectPut &#123;&#125; = &#123;&#125;\", key, value); &#125; catch (Exception e) &#123; logger.warn(\"mapObjectPut &#123;&#125; = &#123;&#125;\", key, value, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 移除Map缓存中的值 * @param key 键 * @param value 值 * @return */ public long mapRemove(String key, String mapKey)throws Exception &#123; long result = 0; Jedis jedis = null; try &#123; jedis = getResource(); result = jedis.hdel(key, mapKey); logger.debug(\"mapRemove &#123;&#125; &#123;&#125;\", key, mapKey); &#125; catch (Exception e) &#123; logger.warn(\"mapRemove &#123;&#125; &#123;&#125;\", key, mapKey, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 移除Map缓存中的值 * @param key 键 * @param value 值 * @return */ public long mapObjectRemove(String key, String mapKey) throws Exception &#123; long result = 0; Jedis jedis = null; try &#123; jedis = getResource(); result = jedis.hdel(getBytesKey(key), getBytesKey(mapKey)); logger.debug(\"mapObjectRemove &#123;&#125; &#123;&#125;\", key, mapKey); &#125; catch (Exception e) &#123; logger.warn(\"mapObjectRemove &#123;&#125; &#123;&#125;\", key, mapKey, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 判断Map缓存中的Key是否存在 * @param key 键 * @param value 值 * @return */ public boolean mapExists(String key, String mapKey)throws Exception &#123; boolean result = false; Jedis jedis = null; try &#123; jedis = getResource(); result = jedis.hexists(key, mapKey); logger.debug(\"mapExists &#123;&#125; &#123;&#125;\", key, mapKey); &#125; catch (Exception e) &#123; logger.warn(\"mapExists &#123;&#125; &#123;&#125;\", key, mapKey, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 判断Map缓存中的Key是否存在 * @param key 键 * @param value 值 * @return */ public boolean mapObjectExists(String key, String mapKey)throws Exception &#123; boolean result = false; Jedis jedis = null; try &#123; jedis = getResource(); result = jedis.hexists(getBytesKey(key), getBytesKey(mapKey)); logger.debug(\"mapObjectExists &#123;&#125; &#123;&#125;\", key, mapKey); &#125; catch (Exception e) &#123; logger.warn(\"mapObjectExists &#123;&#125; &#123;&#125;\", key, mapKey, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 删除缓存 * @param key 键 * @return */ public long del(String key) throws Exception&#123; long result = 0; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(key))&#123; result = jedis.del(key); logger.debug(\"del &#123;&#125;\", key); &#125;else&#123; logger.debug(\"del &#123;&#125; not exists\", key); &#125; &#125; catch (Exception e) &#123; logger.warn(\"del &#123;&#125;\", key, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 删除缓存 * @param key 键 * @return */ public long delObject(String key)throws Exception &#123; long result = 0; Jedis jedis = null; try &#123; jedis = getResource(); if (jedis.exists(getBytesKey(key)))&#123; result = jedis.del(getBytesKey(key)); logger.debug(\"delObject &#123;&#125;\", key); &#125;else&#123; logger.debug(\"delObject &#123;&#125; not exists\", key); &#125; &#125; catch (Exception e) &#123; logger.warn(\"delObject &#123;&#125;\", key, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 缓存是否存在 * @param key 键 * @return */ public boolean exists(String key)throws Exception &#123; boolean result = false; Jedis jedis = null; try &#123; jedis = getResource(); result = jedis.exists(key); logger.debug(\"exists &#123;&#125;\", key); &#125; catch (Exception e) &#123; logger.warn(\"exists &#123;&#125;\", key, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 缓存是否存在 * @param key 键 * @return */ public boolean existsObject(String key)throws Exception &#123; boolean result = false; Jedis jedis = null; try &#123; jedis = getResource(); result = jedis.exists(getBytesKey(key)); logger.debug(\"existsObject &#123;&#125;\", key); &#125; catch (Exception e) &#123; logger.warn(\"existsObject &#123;&#125;\", key, e); throw new Exception(e); &#125; finally &#123; returnResource(jedis); &#125; return result; &#125; /** * 获取资源 * @return * @throws JedisException */ public Jedis getResource() throws Exception &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); &#125; catch (JedisException e) &#123; logger.warn(\"getResource.\", e); returnBrokenResource(jedis); throw new Exception(e); &#125; return jedis; &#125; /** * 归还资源 * @param jedis * @param isBroken */ public void returnBrokenResource(Jedis jedis) &#123; if (jedis != null) &#123; /*jedisPool.returnBrokenResource(jedis);*/ jedis.close(); &#125; &#125; /** * 释放资源 * @param jedis * @param isBroken */ public void returnResource(Jedis jedis) &#123; if (jedis != null) &#123; /*jedisPool.returnResource(jedis);*/ jedis.close(); &#125; &#125; /** * 获取byte[]类型Key * @param key * @return */ public byte[] getBytesKey(Object object)&#123; if(object instanceof String)&#123; return StringUtil.getBytes((String)object); &#125;else&#123; return ObjectUtils.serialize(object); &#125; &#125; /** * Object转换byte[]类型 * @param key * @return */ public byte[] toBytes(Object object)&#123; return ObjectUtils.serialize(object); &#125; /** * byte[]型转换Object * @param key * @return */ public Object toObject(byte[] bytes)&#123; return ObjectUtils.unserialize(bytes); &#125;&#125; Object序列化和反序列化工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package test.util;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class ObjectUtils &#123; /** * 序列化对象 * @param object * @return */ public static byte[] serialize(Object object) &#123; byte[] bytes = null; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; try &#123; if (object != null)&#123; baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(object); bytes = baos.toByteArray(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; try &#123; if(null != oos) &#123; oos.close(); &#125; if(null != baos) &#123; baos.close(); &#125; &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return bytes; &#125; /** * 反序列化对象 * @param bytes * @return */ public static Object unserialize(byte[] bytes) &#123; Object object = null; ByteArrayInputStream bais = null; ObjectInputStream ois = null; try &#123; if (bytes != null &amp;&amp; bytes.length &gt; 0)&#123; bais = new ByteArrayInputStream(bytes); ois = new ObjectInputStream(bais); object = ois.readObject(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; try &#123; if(null != ois) &#123; ois.close(); &#125; if(null != bais) &#123; bais.close(); &#125; &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return object ; &#125;&#125; String工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package test.util;public class StringUtil &#123; private static final String CHARSET_NAME = \"UTF-8\"; /** * * @Title: toString * @Description: 把字节流转为字符串 * @param @param content * @param @param charset * @param @return * @return String * @throws */ public static String toString(byte[]content, String charset)&#123; String result = \"\"; try &#123; if(null != content &amp;&amp; content.length &gt; 0)&#123; result = new String(content, charset); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 转换为字节数组 * @param str * @return */ public static String toString(byte[] bytes)&#123; return toString(bytes, \"UTF-8\"); &#125; /** * 转换为字节数组 * @param str * @return */ public static byte[] getBytes(String str)&#123; if (str != null)&#123; try &#123; return str.getBytes(CHARSET_NAME); &#125; catch (Exception e) &#123; return null; &#125; &#125;else&#123; return null; &#125; &#125; &#125; spring配置的片段12345678910111213&lt;!-- 连接池配置 --&gt;&lt;bean id=\"jedisPool\" class=\"redis.clients.jedis.JedisPool\" destroy-method=\"destroy\"&gt; &lt;constructor-arg index=\"0\" ref=\"jedisPoolConfig\" /&gt; &lt;constructor-arg index=\"1\" value=\"$&#123;redis_host&#125;\" type=\"java.lang.String\" /&gt; &lt;constructor-arg index=\"2\" value=\"$&#123;redis_port&#125;\" type=\"int\" /&gt; &lt;constructor-arg index=\"3\" value=\"360000\" type=\"int\" /&gt; &lt;!-- 超时时间 单位ms --&gt; &lt;constructor-arg index=\"4\" value=\"$&#123;redis_password&#125;\" type=\"java.lang.String\" /&gt; &lt;constructor-arg index=\"5\" value=\"$&#123;redis_database&#125;\" type=\"int\" /&gt;&lt;/bean&gt;&lt;!-- 注入 --&gt;&lt;bean id=\"jedisUtils\" class=\"test.util.JedisUtils\"&gt; &lt;property name=\"jedisPool\" ref=\"jedisPool\"/&gt;&lt;/bean&gt;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Angularjs内置过滤器","date":"2016-07-17T03:45:42.000Z","path":"2016/07/17/Angularjs内置过滤器/","text":"currency（货币处理）：&#123;{ num | currency:’¥;’}}date（日期格式化）：&#123;{date | date:’yyyy-MM-dd hh:mm:ss EEEE’}}filter（匹配子串）：&#123;{ childrenArray | filter : ‘a’ }} // 匹配属性值中含有a的&#123;{ childrenArray | filter : 4 }} // 匹配属性值中含有4的&#123;{ childrenArray | filter : {name : ‘i’} }} // 参数是对象，匹配name属性中含有i的&#123;{childrenArray | filter : func }} // 参数是函数，指定返回age&gt;4的$scope.func = function(e) {return e.age&gt;4;}格式化json对象一般用来调试，看看输出的json串jsonlimitTo（限制数组长度或字符串长度）：&#123;{ childrenArray | limitTo : 2 }} // 将会显示数组中的前两项lowercase（小写）uppercase（大写）number（格式化数字） &#123;{num | number:2}}// 保留2位小数orderBy（排序）&lt;div&gt;&#123;{ childrenArray | orderBy : ‘age’ }}&lt;/div&gt; // 按age属性值进行排序，若是-age，则倒序&lt;div&gt;&#123;{ childrenArray | orderBy : orderFunc }}&lt;/div&gt; // 按照函数的返回值进行排序&lt;div&gt;&#123;{ childrenArray | orderBy : [‘age’,’name’] }}&lt;/div&gt; // 如果age相同，按照name进行排序","tags":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://yoursite.com/tags/AngularJs/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"原生数据库访问","date":"2016-07-09T01:26:53.000Z","path":"2016/07/09/原生数据库访问/","text":"本例以mysql为例123456789101112131415161718192021222324252627/*MySQL Data TransferSource Host: localhostSource Database: testTarget Host: localhostTarget Database: testDate: 2016/07/09 09:19:38*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for user 创建表-- ----------------------------CREATE TABLE `user` ( `id` int(11) NOT NULL, `username` varchar(40) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records 填充数据-- ----------------------------INSERT INTO `user` VALUES ('1', '张一', '1');INSERT INTO `user` VALUES ('2', '张二', '2');INSERT INTO `user` VALUES ('3', '张三', '3');INSERT INTO `user` VALUES ('4', '张四', '4');INSERT INTO `user` VALUES ('5', '张五', '5'); 数据库配置文件jdbc.properties1234jdbc_driverClassName=com.mysql.jdbc.Driverjdbc_url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNulljdbc_username=rootjdbc_password=root Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263package test;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Properties;import org.apache.tomcat.dbcp.dbcp.ConnectionFactory;public class Test &#123; private static Properties prop; private static Connection conn = null; private static final String CONFIGNAME = \"jdbc.properties\"; public static void main(String[] args) &#123; // 打开数据库链接 getConnection(); try &#123; // 禁用自动提交 conn.setAutoCommit(false); System.out.println(\"默认的事务隔离级别:\" + conn.getTransactionIsolation()); // 用 conn 创建 Statement 对象类实例 Statement statement = conn.createStatement(); // 插入数据 statement.executeUpdate(\"insert user(id, username, password) values(6, '张六', '6')\"); System.out.println(\"Insert Success\"); System.out.println(\"------------------ 我是分割线 ---------------------\"); // 提交事务 conn.commit(); // 查询的话不需要事务，用ResultSet类的对象，返回查询的结果 String sql = \"select * from user where id = 1\"; ResultSet result = statement.executeQuery(sql_pojo); // 原生的打印结果 while (result.next()) &#123; int id = result.getInt(\"id\"); String username = result.getString(\"username\"); String password = result.getString(\"password\"); System.out.println(\"id: \" + id + \" username: \" + username + \" password: \" + password); &#125; result = statement.executeQuery(sql_pojo); // 转为bean List&lt;User&gt; bean = getBeanList(result); for (int i = 0; i &lt; bean.size(); i++) &#123; System.out.println(bean.get(i).toString()); &#125; System.out.println(\"------------------ 我是分割线 ---------------------\"); String sql_list = \"select * from user\"; result = statement.executeQuery(sql_list); // 原生的打印结果 while (result.next()) &#123; int id = result.getInt(\"id\"); String username = result.getString(\"username\"); String password = result.getString(\"password\"); System.out.println(\"id: \" + id + \" username: \" + username + \" password: \" + password); &#125; result = statement.executeQuery(sql_list); // 转为list List&lt;User&gt; list = getBeanList(result); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i).toString()); &#125; &#125; catch (SQLException e) &#123; if (conn != null)&#123; // 事务回滚 try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125; finally &#123; // 关闭数据库链接 closeConnection(); &#125; &#125; /** * 获取数据库连接 * @throws SQLException */ public static Connection getConnection() &#123; prop = new Properties(); try &#123; prop.load(ConnectionFactory.class.getClassLoader().getResourceAsStream(CONFIGNAME)); Class.forName(prop.getProperty(\"jdbc_driverClassName\")); conn = DriverManager.getConnection( prop.getProperty(\"jdbc_url\"), prop.getProperty(\"jdbc_username\"), prop.getProperty(\"jdbc_password\")); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; /** * 关闭数据库连接 * @throws SQLException */ public static void closeConnection() &#123; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取实体类列表（将原生的数据库访问查询结果Result转为一个POJO） * @param rs * @return * @throws SQLException */ public static &lt;T&gt; List&lt;T&gt; getBeanList(ResultSet rs) throws SQLException &#123; List retultList = resultSetToList(rs); List&lt;T&gt; pojoList = new ArrayList&lt;T&gt;(); for(int i = 0; i &lt; retultList.size(); i++) &#123; T t = (T) MapToBean(new User(), (Map) retultList.get(i)); pojoList.add(t); &#125; return pojoList; &#125; /** * 将ResultSet封装成list 而每条记录对应一个实体Map * @param rs 结果集 * @return * @throws SQLException */ public static List resultSetToList(ResultSet rs) throws SQLException&#123; if(rs == null) &#123; return null; &#125; ResultSetMetaData md = rs.getMetaData(); int columnCount = md.getColumnCount(); List list = new ArrayList(); Map rowData; while (rs.next())&#123; rowData = new HashMap(columnCount); for (int i = 1; i &lt;= columnCount; i++)&#123; rowData.put(md.getColumnName(i),rs.getObject(i)); &#125; list.add(rowData); &#125; return list; &#125; /** * @param bean 需要封装的vo * @param map 需要转换的map * @return 已经封装好数据的vo（object） */ public static Object MapToBean(Object bean, Map map) &#123; Map methods = new HashMap(); Method m[] = bean.getClass().getMethods(); for (int i = 0; i &lt; m.length; i++) &#123; Method method = m[i]; String methodName = method.getName().toUpperCase(); methods.put(methodName, method); &#125; Iterator it = null; String key = \"\"; it = map.keySet().iterator(); while (it.hasNext()) &#123; key = (String) it.next(); String name = \"GET\" + key.toUpperCase(); if (methods.containsKey(name)) &#123; Method setMethod = (Method) methods.get(\"SET\" + key.toUpperCase()); try &#123; if(setMethod!=null)&#123; Object[] obj=null; obj=new Object[1]; obj[0]=map.get(key); setMethod.invoke(bean, obj); &#125; else&#123; continue; &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return bean; &#125; &#125;class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User [id=\" + id + \", username=\" + username + \", password=\" + password + \"]\"; &#125; &#125; Console打印123456789101112131415161718默认的事务隔离级别:4Insert Success------------------ 我是分割线 ---------------------id: 1 username: 张一 password: 1User [id=1, username=张一, password=1]------------------ 我是分割线 ---------------------id: 1 username: 张一 password: 1id: 2 username: 张二 password: 2id: 3 username: 张三 password: 3id: 4 username: 张四 password: 4id: 5 username: 张五 password: 5id: 6 username: 张六 password: 6User [id=1, username=张一, password=1]User [id=2, username=张二, password=2]User [id=3, username=张三, password=3]User [id=4, username=张四, password=4]User [id=5, username=张五, password=5]User [id=6, username=张六, password=6] 查询user表1select * from user 输出结果| id | username | password || :——-: |:————-:| :——–:|| 1 | 张一 | 1 || 2 | 张二 | 2 || 3 | 张三 | 3 || 4 | 张四 | 4 || 5 | 张五 | 5 || 6 | 张六 | 6 |","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"tomcat配置https单/双向验证","date":"2016-06-12T02:51:28.000Z","path":"2016/06/12/tomcat配置https单-双向验证/","text":"tomcat配置https双向验证以windows为例，进入cmd终端，用命令切换进入%JAVA_HOME%/bin目录 1.为服务器生成证书1keytool -genkey -v -alias tomcat -keyalg RSA -keystore D:\\home\\tomcat.keystore -validity 36500 参数简要说明：123“D:\\home\\tomcat.keystore” 表示证书文件的保存路径tomcat.keystore 表示证书文件名称“-validity 36500” 表示证书有效期，36500表示100年，默认值是90天 “tomcat”为自定义证书名称 输入keystore密码（必填项） 此处需要输入大于6个字符的字符串您的名字与姓氏是什么？（必填项） 必须是TOMCAT部署主机的域名或者IP[如：baidu.com 或者 119.75.217.109]（就是你将来要在浏览器中输入的访问地址）后面的那些都可以不填，直接敲回车，最后的主密码建议与之前keystore的密码一致）事例如下：12345678910111213141516171819202122C:\\Windows\\system32&gt;keytool -genkey -v -alias tomcat -keyalg RSA -keystore D:\\home\\tomcat.keystore -validity 36500输入keystore密码：123456再次输入新密码：123456您的名字与姓氏是什么？ [Unknown]： baidu.com您的组织单位名称是什么？ [Unknown]： 您的组织名称是什么？ [Unknown]： 您所在的城市或区域名称是什么？ [Unknown]： 您所在的州或省份名称是什么？ [Unknown]： 该单位的两字母国家代码是什么 [Unknown]： CNCN=baidu.com, OU=, O=, L=, ST=, C=CN 正确吗？ [否]： y正在为以下对象生成 1,024 位 RSA 密钥对和自签名证书 (SHA1withRSA)（有效期为 36,500 天）: CN=baidu.com, OU=, O=, L=, ST=, C=CN输入&lt;tomcat&gt;的主密码 （如果和 keystore 密码相同，按回车）：[正在存储 D:\\home\\tomcat.keystore]C:\\Windows\\system32&gt; 2.为客户端生成证书（需要PKCS12格式）1keytool -genkey -v -alias mykey -keyalg RSA -storetype PKCS12 -keystore D:\\home\\client.key.p12 1234567891011121314151617181920C:\\Windows\\system32&gt;keytool -genkey -v -alias mykey -keyalg RSA -storetype PKCS12 -keystore D:\\home\\client.key.p12输入keystore密码：123456再次输入新密码：123456您的名字与姓氏是什么？ [Unknown]： baidu.com您的组织单位名称是什么？ [Unknown]： 您的组织名称是什么？ [Unknown]： 您所在的城市或区域名称是什么？ [Unknown]： 您所在的州或省份名称是什么？ [Unknown]： 该单位的两字母国家代码是什么 [Unknown]： CNCN=baidu.com, OU=, O=, L=, ST=, C=CN 正确吗？ [否]： y正在为以下对象生成 1,024 位 RSA 密钥对和自签名证书 (SHA1withRSA)（有效期为 90 天）: CN=baidu.com, OU=, O=, L=, ST=, C=CN[正在存储 D:\\home\\client.key.p12]C:\\Windows\\system32&gt; 之后，在D:\\home\\路径下，便能看到两个文件12tomcat.keystoreclient.key.p12 3.双击client.key.p12安装 安装需要密码，就是刚才设置的”123456” 安装过程选择“将所有的证书放入下列存储”–“个人”，下一步直至导入完成 4.让服务器信任客户端证书先导出客户端证书为cer格式，然后再添加到keystore中，此过程需要密码，步骤如下：121）keytool -export -alias mykey -keystore D:\\home\\client.key.p12 -storetype PKCS12 -storepass password -rfc -file D:\\home\\client.cer2）keytool -import -v -file D:\\home\\client.cer -keystore D:\\home\\tomcat.keystore 5.查看服务器的证书库此时list命令查看服务器的证书库，可以看到两个证书，一个是服务器证书，一个是受信任的客户端证书 keytool -list -keystore D:\\home\\tomcat.keystore 6.导出服务端证书为cer格式 keytool -keystore D:\\home\\tomcat.keystore -export -alias tomcat -file D:\\home\\tomcat.cer 7.安装服务端证书双击，安装到“将所有的证书放入下列存储”–“受信任的根证书颁发机构” 8.配置Tomcat服务器打开Tomcat根目录下的/conf/server.xml，找到Connector port=”8443”配置段，修改为如下：12345&lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" SSLEnabled=\"true\" maxThreads=\"150\" scheme=\"https\" secure=\"true\" clientAuth=\"true\" sslProtocol=\"TLS\" keystoreFile=\"D:\\\\home\\\\tomcat.keystore\" keystorePass=\"123456\" truststoreFile=\"D:\\\\home\\\\tomcat.keystore\" truststorePass=\"123456\" /&gt; 属性说明： clientAuth:设置是否双向验证，默认为false，设置为true代表双向验证 keystoreFile:服务器证书文件路径 keystorePass:服务器证书密码 truststoreFile:用来验证客户端证书的根证书，此例中就是服务器证书 truststorePass:根证书密码 9.最后在项目的web.xml中 前加入，之后就可以用8443端口访问https请求了123456789&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Protected Context&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt;&lt;/security-constraint&gt; 省去上方的2、3、4、5步骤即为单项配置","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"StaleStateException","date":"2016-06-11T01:25:31.000Z","path":"2016/06/11/StaleStateException/","text":"org.hibernate.StaleStateExceptionorg.hibernate.StaleStateException: Batch update returned unexpected row count from update: 0 actual row count: 0 expected: 1这个错误的原因是当你更新的时候id不对应了，查看hibernate的sql输出，要么就是id原本是自增的，而在新增的时候自己给id赋值了。我遇到的问题是新增的时候忘了调用save()方法，然后就去update()，这时update不到对象，结果就报错了","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"hibernate","slug":"hibernate","permalink":"http://yoursite.com/tags/hibernate/"}]},{"title":"获取URL链接的文件类型","date":"2016-05-22T03:46:01.000Z","path":"2016/05/22/获取URL链接的文件类型/","text":"事例中的URL原本是一个格式为wav的音频文件，file type: audio/x-wav，在保存文件的时候需要判断url是否还有效，这个时候就可以用到HttpURLConnection.guessContentTypeFromStream方法来做判断1234567891011121314151617181920212223242526272829303132333435363738package test;import java.io.BufferedInputStream;import java.io.IOException;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;public class Test &#123; public static void main(String[] args) &#123; HttpURLConnection urlConn = null; URL url = null; BufferedInputStream bis = null; try &#123; url = new URL(\"http://www.ucpaas.com/fileserver/record/aee9011d2ee0f21f67310422ce62e71c_1464078387210374_20160524?sig=648DA4EC9E16704C44E5424D7A29CCD2\"); urlConn = (HttpURLConnection) url.openConnection(); urlConn.connect(); bis = new BufferedInputStream(urlConn.getInputStream()); // HttpURLConnection.guessContentTypeFromStream 可以获取流的类型 System.out.println(\"file type: \" + HttpURLConnection.guessContentTypeFromStream(bis)); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(bis != null) &#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 控制台打印结果：file type: text/html 还可以使用下面这种方式获取文件类型12345678910111213141516171819202122232425package test;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class Test &#123; public static void main(String[] args) &#123; URL url = null; URLConnection conn = null; try &#123; url = new URL(\"http://www.ucpaas.com/fileserver/record/aee9011d2ee0f21f67310422ce62e71c_1464078387210374_20160524?sig=648DA4EC9E16704C44E5424D7A29CCD2\"); conn = url.openConnection(); System.out.println(\"file type: \" + conn.getContentType()); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 控制台打印结果：file type: text/html;charset=utf-8","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"mysql 1044 错误","date":"2016-05-01T15:11:43.000Z","path":"2016/05/01/mysql 1044 错误/","text":"不小心把 mysql 的 ‘root@localhost’ 权限都删了，处理过程记录12345【报错】#1044 - Access denied for user 'root'@'localhost' to database 'mysql' 根据报错的内容在网上搜索出处理方法，在my.ini中的[mysqld]中添加 #skip-grant-tables --授权表，可以在忘记密码的时候使用 skip-external-locking --是跳过外部锁定 skip-name-resolve --禁止DNS解析 12345【报错】 #1130 - Host '127.0.0.1' is not allowed to connect to this MySQL server 注释掉 skip-name-resolve 后不报错了， 但是又是之前的问题， 于是打开 skip-grant-tables 解决，可以打开数据库了，重新为用户加上权限，保存 1234567【报错】#1290 -the mysql server is running with the --skip-grant-tables option so it cannot execute this statement字面意思是说skip-grant-tables这个开着的时候就不可更改网上查找答案，先执行flush privileges后再次授权，flush privileges 命令本质上的作用是将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里。MySQL用户数据和权限有修改后，希望在\"不重启MySQL服务\"的情况下直接生效，那么就需要执行这个命令。通常是在修改ROOT帐号的设置后，怕重启后无法再登录进来，那么直接flush之后就可以看权限设置是否生效。而不必冒太大风险。继续报原来1044的错误 12345【另寻思路】关掉mysql服务，到其他安装了Mysql的服务器（前提是要知道该服务器上Mysql的root用户密码），打开[Mysql的安装目录/var/mysql]，将其中的user.frm、user.MYD、user.MYI三个文件拷贝到出问题服务器的[Mysql的安装目录/var/mysql]目录中。然后重启服务。仍然不行直接将mysql数据库中的user表中的所有N改为Y，注释掉skip-grant-tables重启服务，搞定。 123【总结】首先，所有更改配置文件的操作都需要关服务修改后重启服务才能保证配置生效。关闭mysql服务，在my.ini的[mysqld]中添加skip-grant-tables，打开服务，然后保证能看到用户下所有数据库后，根据#1044 - Access denied for user 'root'@'localhost' to database 'mysql' 这句信息的字面意思，修改'mysql'数据库中的user表，将其中为N权限的全部手动改为Y，关服务，把skip-grant-tables注释掉，重启服务。 遇到的其它错误情况123456789【报错】The user specified as a definer ('root'@'%') does not exist 出现该问题的原因是('root'@'%')没有找到，查看数据库，发现当前登录的是('root'@'localhost')。 报错原因： 数据库中的视图跟存储过程，之前是在另一个数据库使用('root'@'%')登录的时候创建的，且安全性是definer， 备份到新的数据库的时候，当前的('root'@'localhost')没有足够的权限去操作，所以只需把视图和存储过程高级设置中的的安全性选项改为invoker即可。 DEFINER的作用是用于指明存储过程是由哪个用户定义的; INVOKER用于指定哪些用户有调用存储过程的权限;","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"判断浏览器版本","date":"2016-04-16T12:01:26.000Z","path":"2016/04/16/判断浏览器版本/","text":"JS判断浏览器版本123456789101112131415161718&lt;script type=\"text/javascript\"&gt; function getBrowser() &#123; var userAgent = navigator.userAgent.toLowerCase(); var Sys = &#123;&#125;; var s; // IE (s = ua.match(/msie ([\\d.]+)/)) ? Sys.ie = s[1] : // 火狐 (s = ua.match(/firefox\\/([\\d.]+)/)) ? Sys.firefox = s[1] : // 谷歌 (s = ua.match(/chrome\\/([\\d.]+)/)) ? Sys.chrome = s[1] : // opera (s = ua.match(/opera.([\\d.]+)/)) ? Sys.opera = s[1] : // safari (s = ua.match(/version\\/([\\d.]+).*safari/)) ? Sys.safari = s[1] : 0; &#125;&lt;/script&gt; 判断某个浏览器只需要用 if (Sys.ie) 形式就可以判断，若判断浏览器版本只需用 if(Sys.ie == ‘8.0’) 形式，不过谷歌比较特殊，需要使用 if (Sys.chrome.substring(0, 2) == 53) 的形式来处理","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"JDK1.7新特性","date":"2016-04-15T05:36:52.000Z","path":"2016/04/15/JDK1.7特性/","text":"小记jdk7新增的一些好用的小特性123456789101112131415161718192021// 1.7新增数字字面量下划线支持：int 和 long 可使用下划线分割数字int oneMillion = 1_000_000;System.out.println((oneMillion * 2) + \"---\" + oneMillion);// 1.7新增二进制字面量支持byte aByte = (byte) 0b1000;short aShort = (short) 0b010;System.out.println(aByte + \"-\" + aShort);// 1.7新增自动关闭流支持，不必在finally中写关闭操作try(InputStream is = new InputStream(file);) &#123;&#125; catch (Exception e) &#123;&#125;// 反射try &#123; Class cls = Class.forName(\"chb.test.reflect.Student\"); Method m = cls.getDeclaredMethod(\"方法名\", new Class[]&#123;int.class, String.class&#125;); m.invoke(cls.newInstance(), 20, \"chb\");&#125; catch (Exception e) &#123; e.printStackTrace();&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Log4j发邮件配置","date":"2016-04-08T01:12:09.000Z","path":"2016/04/08/log4j发邮件配置/","text":"引入log4j.jar包，这里解释一下三个包的关系：slf4j-api 本质就是一个接口定义slf4j-log4j12 是链接slf4j-api和log4j中间的适配器。它实现了slf4j-api中StaticLoggerBinder接口，从而使得在编译时绑定的是slf4j-log4j12的getSingleton()方法log4j 是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。 slf4j和log4j经常存在冲突的现在，需要在网上下载对应的版本，以下为无冲突的版本实例1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt;&lt;/dependency&gt; log4j.properties文件配置123456789101112131415161718log4j.rootLogger=INFO,stdout,R#输出到控制台log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %5p [%F:%L] : %m%n#输出到日志文件log4j.appender.R=org.apache.log4j.DailyRollingFileAppender#日志文件只输出WARN级别以上的日志log4j.appender.R.Threshold=ERROR#日志文件输出路径log4j.appender.R.File=/usr/local/tomcat7/logs/web/xxx.log#日志输出格式log4j.appender.R.DatePattern='.'yyyy-MM-ddlog4j.appender.R.Append=truelog4j.appender.R.layout=org.apache.log4j.PatternLayoutlog4j.appender.R.layout.ConversionPattern=[%-5p][%d&#123;yyyyMMdd HH:mm:ss,SSS&#125;][%C&#123;1&#125;:%L] %m%n 如果需要利用日志发送邮件，添加activation.jar、mail.jar两个包1234567891011&lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt; 然后配置文件中加入1234567891011121314151617181920212223#log4j的邮件发送appenderlog4j.appender.MAIL=org.apache.log4j.net.SMTPAppender#发送邮件的门槛，仅当等于或高于ERROR（比如FATAL）时，邮件才被发送log4j.appender.MAIL.Threshold=ERROR#缓存文件大小，日志达到1000k时发送Email，但如果是ERROR或FATAL则立即发送 log4j.appender.MAIL.BufferSize=1024KB#此处发送邮件的邮箱帐号log4j.appender.MAIL.From=发送者的邮箱地址，比如xxxemail@163.com#SMTP邮件发送服务器地址（这里以网易邮箱举例，比如谷歌就会是smtp.gmail.com）log4j.appender.MAIL.SMTPHost=smtp.163.com#SMTP发送认证的帐号名，邮箱的名称（不包含@163.com后面的信息）log4j.appender.MAIL.SMTPUsername=xxxemail#SMTP发送认证帐号的密码，邮箱的密码log4j.appender.MAIL.SMTPPassword=发送者的邮箱密码，比如123456789#是否打印调试信息，如果选true，则会输出和SMTP之间的握手等详细信息log4j.appender.MAIL.SMTPDebug=true#邮件主题log4j.appender.MAIL.Subject=xxx项目错误日志#发送到什么邮箱，如果要发送给多个邮箱，则用逗号分隔； log4j.appender.MAIL.To=xxx1@qq.com,xxx2@163.com,xxx3@gmail.com#日志格式log4j.appender.MAIL.layout=org.apache.log4j.PatternLayoutlog4j.appender.MAIL.layout.ConversionPattern=[framework]%d - %c -%-4r[%t]%-5p %c %x -%m%n 如果顺利的话可以正常的发送，但可能会有特殊情况，比如标题乱码（也可能是版本低了），则可以重写 SMTPAppender 看到配置中log4j.appender.MAIL=org.apache.log4j.net.SMTPAppender这一句，这里就是 log4j 输出的控制类，如果有其它个性化的定制，比如认证信息的处理等，都是通过重写SMTPAppender来实现。 123456789101112131415// 邮件标题乱码问题import java.io.UnsupportedEncodingException;import org.apache.log4j.net.SMTPAppender;public class EncodingSMTPAppender extends SMTPAppender &#123; @Override public void setSubject(String subject) &#123; try &#123; subject = new String(subject.getBytes(\"iso8859-1\"), \"utf-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; super.setSubject(subject); &#125; &#125; 还有一个最常见的错误，配置完后发现若发送邮件失败 log4j: ERROR Error occured while sending e-mail notification.则是发送的邮箱没有开启stmp服务 像网易邮箱默认是没有开启smtp服务的，进入 邮箱-设置-POP3/SMTP/IMAP 中，把POP3/SMTP服务和IMAP/SMTP服务都勾选上","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"input标签获取本地图片并显示","date":"2016-04-01T03:31:29.000Z","path":"2016/04/01/获取本地图片并显示/","text":"12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"file\" name=\"file\" id=\"file\" /&gt; &lt;/body&gt; &lt;script&gt; $('#file').change(function(event) &#123; // 根据这个 &lt;input&gt; 获取文件的 HTML5 js 对象 var files = event.target.files; if (files &amp;&amp; files.length &gt; 0) &#123; // 获取目前上传的文件 file = files[0]; // 来在控制台看看到底这个对象是什么 console.log(file); // 那么我们可以做一下诸如文件大小校验的动作 if(file.size &gt; 1024 * 64) &#123; alert('图片大小不能超过 64kB!'); return false; &#125; // 下面是关键的关键，通过这个 file 对象生成一个可用的图像 URL // 获取 window 的 URL 工具 var URL = window.URL || window.webkitURL; // 通过 file 生成目标 url var imgURL = URL.createObjectURL(file); // 用这个 URL 产生一个 &lt;img&gt; 将其显示出来 $(\"#imghead\" ).attr(\"src\", imgURL); &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"图片在数据库的保存与读取","date":"2016-03-28T09:42:32.000Z","path":"2016/03/28/图片在数据库的保存与读取/","text":"将图片上传到服务器（注意：longBlob和Blob可保留的大小不同，longBlob可存储的大小为4GB，而Blob只有65k，根据自己的需求设置字段类型 这里以springmvc+hibernate为例1234567891011121314151617181920212223242526272829303132333435/*** * 上传文件 * 用@RequestParam注解来指定表单上的file为MultipartFile * @param file * @return */@RequestMapping(\"/fileUpload\") public String fileUpload(@RequestParam(\"file\") MultipartFile file) &#123; // 判断文件是否为空 if (!file.isEmpty()) &#123; try(FileInputStream fis = new FileInputStream(file);) &#123; // 限制文件大小不超过65k long size = fis.available(); if(size &gt; 65 * 1024) &#123; return \"more than MaxSize\"; &#125; // Hibernate 3使用Hibernate.createBlob(fis)，Hibernate 4已经弃用，使用如下方法： LobHelper lh = session.getLobHelper(); byte[] b = new byte[(int) size]; fis.read(b); Blob blob = lh.createBlob(b); // 假设这里要保存用户头像 User user = new User(); user.setPortrait(blob); Session session = HibernateSessionFactory.getSession(); session.beginTransaction(); session.save(user); session.getTransaction().commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 返回结果 return \"SUCCESS\"; &#125; 客户端读取图片1&lt;img src=\"showimage?userId = 1\" id=\"image\" width=\"100px\" height=\"100px\"&gt;&lt;/img&gt; 服务端读取blob图片文件（注意：返回的是流的形式）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*** * 读取图片 * 用@RequestParam * @param userId * @return */@RequestMapping(\"/showimage\") public @ResponseBody InputStream showImage(@RequestParam(\"userId\") Long userId) &#123; User user = null; try &#123; Session session = HibernateSessionFactory.getSession(); user = (User) session.get(User.class, id); if (null == user) return null; session.close; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Blob blob = user.getPortrait(); byte[] data = null; PrintWriter out = null; // 可以将流写到文件中然后把文件地址返回给客户端去访问，这里将以流的形式返回给客户端 InputStream inputStream = null; try(InputStream is = blob.getBinaryStream();) &#123; int length = (int) blob.length(); data = new byte[length]; is.read(data); out = response.getWriter(); inputStream = new ByteArrayInputStream(data); int a = inputStream.read(); while (a != -1) &#123; out.print((char) a); // 以流的形式返回给客户端 a = inputStream.read(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(null != out) &#123; out.flush(); out.close(); &#125; if (null != inputStream) &#123; inputStream.cloase(); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"URL下载资源","date":"2016-03-16T14:53:18.000Z","path":"2016/03/16/URL下载资源/","text":"url资源下载，有一个很实用的工具类FileUtils1234567try &#123; URL httpUrl = new URL(\"http://xxx\"); File f = new File(\"存储路径+文件名+后缀\"); FileUtils.copyURLToFile(httpUrl, f); &#125; catch (Exception e) &#123; e.printStackTrace();&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java操作Excel工具","date":"2016-03-15T13:19:09.000Z","path":"2016/03/15/Java操作Excel/","text":"选择：Apache POI 和 JXL JXL没有使用过，网上查到的两者区别 JVM虚拟机内存消耗的情况：1). 数据量3000条数据,每条60列.JVM虚拟机内存大小64M. 2). 使用POI:运行到2800条左右就报内存溢出. （实际使用过程操作的数据都是30列几千行以上，并没有这样的现象存在）3). 使用JXL:3000条全部出来,并且内存还有21M的空间. 其它：1). 若导出图片的操作较多，建议使用JXL2). 额外的Excel特性,例如处理公式,创建单元格样式–颜色,边框,字体,头部,脚部,数据验证,图像,超链接等.，建议使用POI3).POI支持XLS和XLSX，且代码看起来比较简洁，而JXL只支持XLS 使用：以Apache POI为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242import java.io.File;import java.io.FileInputStream;import java.text.DateFormat;import java.text.SimpleDateFormat;import org.apache.poi.hssf.usermodel.HSSFDateUtil;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.ss.util.CellRangeAddress;import org.apache.poi.xssf.usermodel.XSSFWorkbook;public class ExcelUtil &#123; /** * @Title: getWorkBook * @Description: 获取Excel文件对象 * @param @param f * @param @return * @return Workbook * @throws */ public Workbook getWorkBook(File f) &#123; Workbook wb = null; try (FileInputStream fis = new FileInputStream(f)) &#123; // 根据后缀获取Excel对象 if (f.getName().indexOf(\".xlsx\") &gt; 1) &#123; wb = new XSSFWorkbook(fis); &#125; else &#123; wb = new HSSFWorkbook(fis); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return wb; &#125; /** * @Title: readExcel * @Description: 读取Excel文件 * @param @param wb * @param @param sheetIndex sheet页下标，从 0 开始 * @param @param startReadLine 开始读取的行，从 0 开始 * @param @param tailLine 最后读取的行号 * @return void * @throws */ public void readExcel(Workbook wb, int sheetIndex, int startReadLine, int tailLine) &#123; Sheet sheet = wb.getSheetAt(sheetIndex); Row row = null; // 行 for (int i = startReadLine; i &lt; sheet.getLastRowNum() - tailLine + 1; i++) &#123; row = sheet.getRow(i); // 列 for (int j = 0; j &lt; row.getLastCellNum(); j++) &#123; Cell cell = row.getCell(j); // 具体操作业务 &#125; &#125; &#125; /** * @Title: getMergedRegionValue * @Description: 获取合并单元格的值 * @param @param sheet * @param @param row * @param @param column * @param @return * @return String * @throws */ public String getMergedRegionValue(Sheet sheet, int row, int column) &#123; // 获取一个 Sheet 表中合并单元格的数量 int sheetMergeCount = sheet.getNumMergedRegions(); for (int i = 0; i &lt; sheetMergeCount; i++) &#123; CellRangeAddress ca = sheet.getMergedRegion(i); int firstColumn = ca.getFirstColumn(); int lastColumn = ca.getLastColumn(); int firstRow = ca.getFirstRow(); int lastRow = ca.getLastRow(); if (row &gt;= firstRow &amp;&amp; row &lt;= lastRow) &#123; if (column &gt;= firstColumn &amp;&amp; column &lt;= lastColumn) &#123; Row fRow = sheet.getRow(firstRow); Cell fCell = fRow.getCell(firstColumn); return getCellValue(fCell); &#125; &#125; &#125; return null; &#125; /** * @Title: isMergeRow * @Description: 判断合并了行 * @param @param sheet * @param @param row * @param @param column * @param @return * @return boolean * @throws */ public boolean isMergeRow(Sheet sheet, int row, int column) &#123; // 获取一个 Sheet 表中合并单元格的数量 int sheetMergeCount = sheet.getNumMergedRegions(); for (int i = 0; i &lt; sheetMergeCount; i++) &#123; CellRangeAddress ca = sheet.getMergedRegion(i); int firstColumn = ca.getFirstColumn(); int lastColumn = ca.getLastColumn(); int firstRow = ca.getFirstRow(); int lastRow = ca.getLastRow(); if (row == firstRow &amp;&amp; row == lastRow) &#123; if (column &gt;= firstColumn &amp;&amp; column &lt;= lastColumn) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * @Title: isMergedRegion * @Description: 判断指定的单元格是否是合并单元格 * @param @param sheet * @param @param row * @param @param column * @param @return * @return boolean * @throws */ public boolean isMergedRegion(Sheet sheet, int row, int column) &#123; int sheetMergeCount = sheet.getNumMergedRegions(); for (int i = 0; i &lt; sheetMergeCount; i++) &#123; CellRangeAddress ca = sheet.getMergedRegion(i); int firstColumn = ca.getFirstColumn(); int lastColumn = ca.getLastColumn(); int firstRow = ca.getFirstRow(); int lastRow = ca.getLastRow(); if (row &gt;= firstRow &amp;&amp; row &lt;= lastRow) &#123; if (column &gt;= firstColumn &amp;&amp; column &lt;= lastColumn) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * @Title: hasMerged * @Description: 判断 Sheet 页中是否含有合并单元格 * @param @param sheet * @param @return * @return boolean * @throws */ public boolean hasMerged(Sheet sheet) &#123; return sheet.getNumMergedRegions() &gt; 0 ? true : false; &#125; /** * @Title: mergeRegion * @Description: 合并单元格 * @param @param sheet * @param @param firstRow 开始行 * @param @param lastRow 结束行 * @param @param firstCol 开始列 * @param @param lastCol 结束列 * @return void * @throws */ public void mergeRegion(Sheet sheet, int firstRow, int lastRow, int firstCol, int lastCol) &#123; sheet.addMergedRegion(new CellRangeAddress(firstRow, lastRow, firstCol, lastCol)); &#125; /** * @Title: getCellValue * @Description: 获取单元格的值 * @param @param cell * @param @return * @return String * @throws */ public String getCellValue(Cell cell) &#123; if (cell == null) &#123; return null; &#125; // 注意： 有时看到单元格是空的，但可能并不是null，只要编辑过的单元格， // 删除之后，其实那个位置的对象时存在的，所以可以用这个方法判空 // ps： 如果是合并列，不管合并前哪个单元格有值，如ABC列，合并后AB列读取到的都会是该类型 if (cell.getCellType() == Cell.CELL_TYPE_BLANK) &#123; return \"\"; &#125; // 字符型 if (cell.getCellType() == Cell.CELL_TYPE_STRING) &#123; return cell.getStringCellValue(); &#125; // 布尔型 if (cell.getCellType() == Cell.CELL_TYPE_BOOLEAN) &#123; return String.valueOf(cell.getBooleanCellValue()); &#125; // 数字型 if (cell.getCellType() == Cell.CELL_TYPE_NUMERIC) &#123; /* 因为日期和数字都是 Cell.CELL_TYPE_NUMERIC 类型，且 cell.getNumericCellValue() 返回的是 double 型，利用 HSSFDateUtil.isCellDateFormatted() 可判断是否是日期类型，但 日期格式只能处理yyyy-MM-dd, d/m/yyyy h:mm, HH:mm 等不含中文文字的日期格式，如需识别中文， 只能根据样式来判断，以下是Excel中所有自定义的中文样式，代码if语句中也已添加所有相关中文日期，嫌麻烦可以看文末 */ /* yyyy年m月d日---31 yyyy年m月------57 m月d日---------58 h\"时\"mm\"分\"--32 h\"时\"mm\"分\"ss\"秒\"--33 上午/下午h\"时\"mm\"分\"--55 上午/下午h\"时\"mm\"分\"ss\"秒\"--56 */ if (HSSFDateUtil.isCellDateFormatted(cell) || cell.getCellStyle().getDataFormat() == 31 || cell.getCellStyle().getDataFormat() == 32 || cell.getCellStyle().getDataFormat() == 33 || cell.getCellStyle().getDataFormat() == 55 || cell.getCellStyle().getDataFormat() == 56 || cell.getCellStyle().getDataFormat() == 57 || cell.getCellStyle().getDataFormat() == 58) &#123; DateFormat df = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\"); return df.format(cell.getDateCellValue()); &#125; else &#123; cell.setCellType(Cell.CELL_TYPE_STRING); return cell.getStringCellValue(); &#125; &#125; return null; &#125; &#125; 对于中文日期，也可以直接修改（我用的是POI3.6）org.apache.poi.ss.usermodel.DateUtil.isCellDateFormatted(Cell cell) 的源码，以下是源码1234567891011121314public static boolean isCellDateFormatted(Cell cell) &#123; if (cell == null) return false; boolean bDate = false; double d = cell.getNumericCellValue(); if ( DateUtil.isValidExcelDate(d) ) &#123; CellStyle style = cell.getCellStyle(); if(style==null) return false; int i = style.getDataFormat(); String f = style.getDataFormatString(); bDate = isADateFormat(i, f); // 这里调用了日期判断 &#125; return bDate;&#125; 在方法DateUtil.isADateFormat(int formatIndex, String formatString)中找到String fs = formatString;在后面加入中文过滤，重新生成class即可，但是不推荐直接修改源码1fs = fs.replaceAll(\"[\\\"|\\']\",\"\").replaceAll(\"[年|月|日|时|分|秒|毫秒|微秒]\", \"\");","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"}]},{"title":"eclipse从svn检出项目报错","date":"2016-03-13T05:21:23.000Z","path":"2016/03/13/eclipse从svn检出项目报错/","text":"从svn把项目导入到eclipse后出现错误，运行又没有问题，提示如下：123Description Resource Path Location TypeTarget runtime com.genuitec.embedded.tomcat.runtime.v70 is not defined. XXX Unknown Faceted Project Problem 解决方法：找到项目目录下的.settings/org.eclipse.wst.common.project.facet.core.xml文件1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;faceted-project&gt; &lt;!-- 将这一句删除后刷新一下项目即可 --&gt; &lt;runtime name=\"com.genuitec.embedded.tomcat.runtime.v70\"/&gt; &lt;fixed facet=\"jst.web\"/&gt; &lt;fixed facet=\"wst.jsdt.web\"/&gt; &lt;fixed facet=\"java\"/&gt; &lt;installed facet=\"java\" version=\"1.7\"/&gt; &lt;installed facet=\"jst.web\" version=\"3.0\"/&gt; &lt;installed facet=\"wst.jsdt.web\" version=\"1.0\"/&gt;&lt;/faceted-project&gt; 原因：新导入的工程出错的可能性非常高，但大多数都是缺少jar包导致的。还有一种缺少或者是错误的类库（比如JDK、Tomcat等等）。这里是因为跟项目原先导出时所使用的Tomcat冲突了。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"svn","slug":"svn","permalink":"http://yoursite.com/tags/svn/"},{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]}]